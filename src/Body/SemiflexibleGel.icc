// -*- C++ -*-
//----------------------------------------------------------------------
//
//                         William S. Klug
//                University of California Los Angeles
//                 (C) 2004-2008 All Rights Reserved
//
//----------------------------------------------------------------------

/*! 
  \file SemiflexibleGel.cc

  \brief SemiflexibleGel is a concrete class derived from Body, implementing
  the concept of a collection of cross-linked semiflexible polymers (i.e., beams)

*/

#if defined(_OPENMP)
#include <omp.h>
#endif

namespace voom {

      
  template<int N>
  SemiflexibleGel<N>::SemiflexibleGel(DefNodeContainer & dNodes, PeriodicBox * box, double filDens, int nodesPerFil, double nodeLen, const string & bondType, bool cutOffEnds, const PropertyList & properties) {
    //double kBond, double kAngle, double visc, double kT, double dt, double kcl, bool prestress, double nematic, bool computeCD)
 
    // check for the necessary parameters in the property list and
    // extract generic parameters

    ConstPropertyIterator p = properties.find("kT");
    assert( p != properties.end() );
    double kT = atof(p->second.data());

    p = properties.find("angle stiffness");
    assert( p != properties.end() );
    double kAngle = atof(p->second.data());

    p = properties.find("bond stiffness");
    assert(p != properties.end());
    double kBond = atof(p->second.data());

    p = properties.find("viscosity");
    assert( p != properties.end() );
    double visc = atof(p->second.data());

    p = properties.find("time step");
    assert( p != properties.end() );
    double dt = atof(p->second.data()); 

    p = properties.find("crosslink stiffness");
    assert( p != properties.end() );
    double kcl = atof(p->second.data());

    double maxPrestress = -1.0;
    p = properties.find("maximum prestress");
    if(p != properties.end()) {
      maxPrestress = kT*atof(p->second.data());
    }

    bool prestress;
    std::string prestressStr;
    p = properties.find("prestress");
    assert(p != properties.end());
    prestressStr.assign(p->second);
    if(prestressStr.find("true") != string::npos) prestress = true;
    else prestress = false;

    std::map< int, int > filLens;
    std::string polydispStr;
    bool longshort = false;
    bool exponential = false;
    double lsratio = 1.0; 
    double lsfrac = 0.0;
    int nLongNodes;
    double expmnl = 0.0;
    double expmin = 0.0;
    p = properties.find("polydispersity");
    if(p != properties.end()) {
      polydispStr.assign(p->second);
      if(polydispStr.find("LongShort") != string::npos) {
	//insert here for long and short network
	longshort = true;
	p = properties.find("longshortratio");
	assert(p != properties.end());
	lsratio = atof(p->second.data());
	nLongNodes = (int)(lsratio*(nodesPerFil-1)) + 1;
	p = properties.find("longfraction");
	assert(p != properties.end());
	lsfrac = atof(p->second.data());
	assert(lsfrac <= 1.0);
      }
      else if(polydispStr.find("Exponential") != string::npos){
	//insert here for exponential distributed length network
	exponential = true;
	expmnl = nodeLen*(nodesPerFil-1);
	p = properties.find("minlength");
	assert(p != properties.end());
	expmin = atof(p->second.data());
      }
    }

    NematicProbTable npt;
    bool donem = false;
    double nematic = 0.0;
    std::string orientationPDF;
    p = properties.find("nematic PDF param");
    if(p != properties.end()) {
      nematic = atof(p->second.data());
      donem = true;
      p = properties.find("orientational PDF");
      if(p != properties.end()) {
	if(p->second.find("Lorentzian") != string::npos) {
	  orientationPDF = "Lorentzian";
	  npt.setPDF(1);
	  npt.setTable(nematic);
	}
	else {
	  orientationPDF = "Gaussian";
	  npt.setPDF(0);
	  npt.setTable(nematic);
	}
      }
      else {
	orientationPDF = "Gaussian";
	npt.setPDF(0);
	npt.setTable(nematic);
      }
    }
    _nematicOP = 0.0;

    ranlib::Normal<double> rngps(0,sqrt(kT/kAngle));
    rngps.seed((unsigned int)time(0));
    ranlib::Uniform<double> rnguni;
    rnguni.seed((unsigned int)time(0));
    ranlib::Exponential<double> rngexp(expmnl-expmin);
    rngexp.seed((unsigned int)time(0));

    _box = box;
    VectorND size( _box->size() );
    double vol=1.0;
    for(int i=0; i<N; i++) {
      vol *= size[i];
    }
    int nFils = (int)(filDens*vol);
    int id = 0;
    NodeBase::DofIndexMap idx(N);
    DefNode * newDN;
    VectorND startPos;
    VectorND oldVec;
    VectorND newVec;
    double newAng;

    int failedCLAttempts = 0;	

    std::cout << "Starting gel creation." << std::endl << "0 filaments created." << std::endl;
    for(int i=0; i<nFils; i++) {
      rngps.seed((unsigned int)time(0)+i);
      rnguni.seed((unsigned int)time(0)+i);
      rngexp.seed((unsigned int)time(0)+i);
      int nNodesthisFil;
      if(exponential) {
	nNodesthisFil = (int)((rngexp.random()+expmin)/nodeLen) + 1;
	if(filLens.find(nNodesthisFil-1) != filLens.end()) (filLens.find(nNodesthisFil-1))->second++;
	else filLens[nNodesthisFil-1] = 1;
      }
      else if(longshort) {
	if(rnguni.random() < lsfrac) nNodesthisFil = nLongNodes;
	else nNodesthisFil = nodesPerFil;
	if(filLens.find(nNodesthisFil-1) != filLens.end()) (filLens.find(nNodesthisFil-1))->second++;
	else filLens[nNodesthisFil-1] = 1;
      }
      else nNodesthisFil = nodesPerFil;
      DefNodeContainer tmpDNC(nNodesthisFil);
      // place the first node in the filament //
      for(int k=0; k<N; k++) {
	idx[k] = N*id + k;
	startPos[k] = size[k]*(rnguni.random());
      }
      newDN = new BrownianNode<N>(id,idx,startPos,startPos);
      newDN->setId(id);
      tmpDNC[0] = newDN;
      dNodes.push_back(newDN);
      // place the second node at some random angle //
      id++;
      for(int k=0; k<N; k++) {
	idx[k] = N*id + k;
      }
      if(!donem) {
	newAng = 2.0*M_PI*(rnguni.random());
      }
      else {
	newAng = npt.findAngle(rnguni.random());
	if(rnguni.random() < .5) {
	  newAng = -newAng;
	}
	if(rnguni.random() < .5) {
	  newAng += M_PI;
	}
      }
      startPos[0] = nodeLen*cos(newAng) + (tmpDNC[0]->point())[0];
      startPos[1] = nodeLen*sin(newAng) + (tmpDNC[0]->point())[1];
      newDN = new BrownianNode<N>(id,idx,startPos,startPos);
      newDN->setId(id);
      tmpDNC[1] = newDN;
      dNodes.push_back(newDN);
      id++;
      // now place the rest of the nodes, choosing the angles from a Boltzmann distribution //
      for(int j=2; j<nNodesthisFil; j++) {
	rnguni.seed((unsigned int)time(0)+i*nodesPerFil+j);
	rngps.seed((unsigned int)time(0)+i*nodesPerFil+j);
	for(int k=0; k<N; k++) {
	  idx[k] = N*id + k;
	}
	oldVec = tmpDNC[j-1]->point() - tmpDNC[j-2]->point();
	if(prestress) {
	  newAng = rngps.random();
	  newVec[0] = oldVec[0]*cos(newAng) + oldVec[1]*sin(newAng);
	  newVec[1] = oldVec[1]*cos(newAng) - oldVec[0]*sin(newAng);
	}
	else {
	  newVec = oldVec;
	}
	startPos = tmpDNC[j-1]->point() + newVec;
	newDN = new BrownianNode<N>(id,idx,startPos,startPos);
	newDN->setId(id);
	tmpDNC[j] = newDN;
	dNodes.push_back(newDN);
	id++;
      }
      // recalculate nematic OP //
      VectorND e2e;
      e2e = tmpDNC[tmpDNC.size()-1]->point() - tmpDNC[0]->point();
      _nematicOP += (2.0*sqr(e2e[0]/norm2(e2e)) - 1.0)/nFils;

      // add the filament to the gel //
      if(bondType == "Spring") {
	addFilament(tmpDNC,kBond,kAngle,visc,kT,dt);
      }
      else {
	double kC = kAngle*nodeLen;
	
	p = properties.find("fit order");
	assert(p != properties.end());
	int fitOrder = atoi(p->second.data());
	
	p = properties.find("F_max");
	assert(p != properties.end());
	double F_max = atof(p->second.data());

	addFilament(tmpDNC,kAngle,visc,kT,dt,kC,fitOrder,F_max);
      }
      // now go through the existing filaments and add crosslinks //
      Filament * fnew = filament(i);
      for(int l=0; l<i; l++) {
	Filament * fold = filament(l);
	VectorND sep;
	sep = ((fold->nodes)[0])->point() - tmpDNC[0]->point();
	_box->mapDistance(sep);
	VectorND e2e2;
	e2e2 = (fold->nodes[0])->point() - (fold->nodes[fold->nodes.size()-1])->point();
	if(norm2(sep) <= norm2(e2e2)+norm2(e2e)) {
	  bool didAttach = attachCrosslink(fnew,fold,kcl,maxPrestress);
	  if(!didAttach) failedCLAttempts++;
	}
      }
      if((i+1)%100 == 0) {
	std::cout << i+1 << " filaments created." << std::endl;
      }
    }
    std::cout << std::endl;
    
    int nCrosslinks = _crosslinks.size();
    int nConstraints = _constraints.size();

    if(cutOffEnds) cutOffEndsandCCD(kcl,dNodes);
    else computeCrossDistro(kcl);
    
    _output = paraview;
    std::cout << "Set up gel with " << nFils << " filaments, " << nodesPerFil << " nodes per filament for a total of " << nFils*nodesPerFil << " nodes (self-consistency check: # of nodes in container = " << dNodes.size() << ")" << std::endl;
    std::cout << "Total # of motors = " << _motors.size() << ", total # of crosslinks = " << nCrosslinks << ", total # of constraints = " << nConstraints << "." << std::endl; 
    std::cout << "Failed to crosslink filaments " << failedCLAttempts << " times." << std::endl;
  }
  
  template<int N>
  SemiflexibleGel<N>::SemiflexibleGel(std::string fileName, DefNodeContainer & nodes, std::string bondType, bool cutOffEnds, const PropertyList & properties, double minLength) {
    
    // first, read in necessary parameters from property list //
    ConstPropertyIterator p = properties.find("kT");
    assert( p != properties.end() );
    double kT = atof(p->second.data());

    p = properties.find("bending modulus");
    assert( p != properties.end() );
    double kC = atof(p->second.data());

    p = properties.find("l_B");
    assert(p != properties.end());
    double l_B = atof(p->second.data());

    p = properties.find("viscosity");
    assert( p != properties.end() );
    double visc = atof(p->second.data());

    p = properties.find("time step");
    assert( p != properties.end() );
    double dt = atof(p->second.data()); 

    p = properties.find("crosslink stiffness");
    assert( p != properties.end() );
    double kcl = atof(p->second.data());

    double maxPrestress = -1.0;
    p = properties.find("maximum prestress");
    if(p != properties.end()) {
      maxPrestress = kT*atof(p->second.data());
    }

    double mu = kC/sqr(l_B);

    //     bool computeCD;
    //     std::string computeCDStr;
    //     p = properties.find("calculate crosslink distribution");
    //     assert(p != properties.end());
    //     computeCDStr.assign(p->second);
    //     if(computeCDStr.find("true") != string::npos) computeCD = true;
    //     else computeCD = false;

    //need to read in stiffratio because it's not stored
    double stretchstiffratio = 1.0;
    double bendstiffratio = 1.0;
    double lsfrac = -1.0;
    std::string polydispStr;
    bool longshort = false;
    p = properties.find("polydispersity");
    if(p != properties.end()) {
      polydispStr.assign(p->second);
      if(polydispStr.find("LongShort") != string::npos) {
	longshort = true;
	p = properties.find("longfraction");
	assert(p != properties.end());
	lsfrac = atof(p->second.data());
	assert(lsfrac <= 1.0);
	p = properties.find("stretchstiffratio");
	assert(p != properties.end());
	stretchstiffratio = atof(p->second.data());
	p = properties.find("bendstiffratio");
	assert(p != properties.end());
        bendstiffratio = atof(p->second.data());
      }
      else if(polydispStr.find("Exponential") != string::npos){
	//need to fill in content
	std::cout << "ERROR: not implemented yet !!!!" << std::endl;
      }
    }

    // get size (in bytes) of ints and doubles on this machine //
    int intSize = sizeof(int);
    int doubleSize = sizeof(double);
    
    // open the file at the end to get size //
    std::ifstream inFile(fileName.data(), ios::in | ios::binary | ios::ate);
    std::cout << "Read in gel file." << std::endl;
    ifstream::pos_type fsize = inFile.tellg();
    
    // reset file to beginning //
    inFile.seekg(0,ios::beg);
    
    // read in system size and set up PeriodicBox //
    VectorND sysSize;
    for(int i=0; i<N; i++) {
      double curSS;
      inFile.read((char *)(&curSS),doubleSize);
      sysSize[i] = curSS;
    }
    PeriodicBox * box = new LeesEdwards(sysSize[0],sysSize[1],0.0);
    //box->setShear(0.0);
    setBox(box);
    
    // read in # of filaments
    int nFils;
    inFile.read((char *)(&nFils),intSize);

    NodeBase::DofIndexMap idx(N);
    int id = 0;
    DefNode * newDN;

    // read in nodal data and create gel elements //
    for(int j=0; j<nFils; j++) {
      int nNodesHere;
      inFile.read((char *)(&nNodesHere),intSize);
      DefNodeContainer tmpDNC(nNodesHere);
      for(int k=0; k<nNodesHere; k++) {
	VectorND curPos;
	VectorND refPos;
	for(int kdof=0; kdof<N; kdof++) {
	  idx[kdof] = N*id + kdof;
	  double cpdof;
	  inFile.read((char *)(&cpdof),doubleSize);
	  curPos[kdof] = cpdof;
	}
	for(int kdof=0; kdof<N; kdof++) {
	  double rpdof;
	  inFile.read((char *)(&rpdof),doubleSize);
	  refPos[kdof] = rpdof;
	}
	newDN = new BrownianNode<N>(id,idx,refPos,curPos);
	newDN->setId(id);
	tmpDNC[k] = newDN;
	nodes.push_back(newDN);
	id++;
      }

//       //recalculate nematic order parameter //
//       VectorND e2e;
//       e2e = tmpDNC[tmpDNC.size()-1]->point() - tmpDNC[0]->point();
//       _nematicOP += (2.0*sqr(e2e[0]/norm2(e2e)) - 1.0)/nFils;

      //add the filament to the gel //
//       dL = norm2(tmpDNC[0]->position()-tmpDNC[1]->position());
//       kAngle = kC/dL;
      double filstrestiff, filbendstiff;
      if(bondType == "Spring") {
	if(j < lsfrac*nFils) {//make long filament stiffer
	  filstrestiff = stretchstiffratio*mu;
	  filbendstiff = bendstiffratio*kC;
	}
	else {
	  filstrestiff = mu;
	  filbendstiff = kC;
	}
	addFilament(tmpDNC,filbendstiff,filstrestiff,visc,kT,dt,minLength);
      }
      else {
	p = properties.find("fit order");
	assert(p != properties.end());
	int fitOrder = atoi(p->second.data());
	
	p = properties.find("F_max");
	assert(p != properties.end());
	double F_max = atof(p->second.data());

	//addFilament(tmpDNC,kAngle,visc,kT,dt,kC,fitOrder,F_max);
      }
    }

    std::cout << "SemiflexibleGel constructor: read in data on " << nFils << " filaments; now setting up crosslinks." << std::endl;

    // now read in data on crosslinks //
    if(kcl < 0.0) {
      bool doRelax = false;
      if(maxPrestress > 0.0) {
	doRelax = true;
      }
      int nCL;
      inFile.read((char *)(&nCL),intSize);
      for(int cln=0; cln<nCL; cln++) {
	int slaveFil;
	int slaveNode;
	int mastFil;
	int mastNode;
	inFile.read((char *)(&slaveFil),intSize);
	inFile.read((char *)(&slaveNode),intSize);
	inFile.read((char *)(&mastFil),intSize);
	inFile.read((char *)(&mastNode),intSize);
	DefNode * mast = filament(mastFil)->nodes[mastNode];
	DefNode * slave = filament(slaveFil)->nodes[slaveNode];
	PeriodicTie<N> * pt = new PeriodicTie<N>(mast,slave,_box,doRelax);
	addConstraint(pt);
	_crossNodeMap.insert(pair< DefNode*, DefNode* >(slave,mast));
	_crossNodeMap.insert(pair< DefNode*, DefNode* >(mast,mast));
      }
    }
    
    else {
      // code in later //
    }
    

    // fix //
    if(cutOffEnds) cutOffEndsandCCD(kcl,nodes);

    _output = paraview;
    std::cout << "Finished retrieving gel from file " << fileName << "." << std::endl;
    std::cout << "Total # of motors = " << _motors.size() << ", total # of crosslinks = " << _crosslinks.size() << ", total # of constraints = " << _constraints.size() << "." << std::endl;
    std::cout << "Elastic element properties: kC = " << kC <<", mu = " << mu << std::endl;
    inFile.close();

    int nAngleSprings = 0;
    int nBonds = 0;
    int nRods = 0;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      nAngleSprings += (*fi)->angles.size();
      nBonds += (*fi)->bonds.size();
      nRods += (*fi)->rods.size();
    }
    
    std::cout << "Set up gel with " 
	      << nFils << " filaments, " 
	      << nAngleSprings << " angle springs, "
	      << nBonds << " bonds, and "
	      << nRods << " brownian rods."
	      << std::endl;

  }
 
  template<int N>
  SemiflexibleGel<N>::SemiflexibleGel(DefNodeContainer & dNodes, PeriodicBox * box, double filDens, double filLength, const string & bondType, bool cutOffEnds, double minLength, const PropertyList & properties) {
    // Adaptively mesh the gel. //
    ConstPropertyIterator p = properties.find("kT");
    assert( p != properties.end() );
    double kT = atof(p->second.data());

    p = properties.find("angle stiffness");
    assert( p != properties.end() );
    double kappa = atof(p->second.data());

    p = properties.find("bond stiffness");
    assert(p != properties.end());
    double mu = atof(p->second.data());

    p = properties.find("viscosity");
    assert( p != properties.end() );
    double visc = atof(p->second.data());

    p = properties.find("time step");
    assert( p != properties.end() );
    double dt = atof(p->second.data());

    p = properties.find("storage file name");
    assert(p != properties.end());
    std::string storageFileName = p->second.data();

    // removalMethod key: 0 = stretch short segments; 1 = delete one in each pair; 2 = collapse nodes //
    int removalMethod = 0;	
    p = properties.find("nearby pair removal method");
    if(p != properties.end()) {
      std::string removeMeth = p->second.data();
      if(removeMeth.find("Delete")!=string::npos) removalMethod = 1;
      else if(removeMeth.find("Collapse")!=string::npos) removalMethod = 2;
    }

    double targetSegLength;
    p = properties.find("target segment length");
    if(p != properties.end()) {
      targetSegLength = atof(p->second.data());
    }
    else targetSegLength = 2.0*minLength;
    //assert(targetSegLength > 0.0);
    //assert(targetSegLength > minLength);

    double maxPrestress = -1.0;
    p = properties.find("maximum prestress");
    if(p != properties.end()) {
      maxPrestress = kT*atof(p->second.data());
    }

    //bool prestress;
    //std::string prestressStr;
    //p = properties.find("prestress");
    //assert(p != properties.end());
    //prestressStr.assign(p->second);
    //if(prestressStr.find("true") != string::npos) prestress = true;
    //else prestress = false;

    std::map< int, int > filLens;
    std::string polydispStr;
    bool longshort = false;
    bool removeLngCross = false;
    bool exponential = false;
    double lsratio = 1.0; 
    double lsfrac = 0.0;
    double stretchstiffratio = 1.0;
    double bendstiffratio = 1.0;
    double expmnl = 0.0;
    double expmin = 0.0;
    p = properties.find("polydispersity");
    if(p != properties.end()) {
      polydispStr.assign(p->second);
      if(polydispStr.find("LongShort") != string::npos) {
	//insert here for long and short network
	longshort = true;
	p = properties.find("longshortratio");
	assert(p != properties.end());
	lsratio = atof(p->second.data());
	p = properties.find("longfraction");
	assert(p != properties.end());
	lsfrac = atof(p->second.data());
	assert(lsfrac <= 1.0);
	p = properties.find("stretchstiffratio");
	assert(p != properties.end());
	stretchstiffratio = atof(p->second.data());
	p = properties.find("bendstiffratio");
	assert(p != properties.end());
	bendstiffratio = atof(p->second.data());
	p = properties.find("removelongcrosslink");
	assert(p != properties.end());
	if(atof(p->second.data())> 0.5) removeLngCross = true;
	else removeLngCross = false;
      }
      else if(polydispStr.find("Exponential") != string::npos){
	//insert here for exponential distributed length network
	exponential = true;
	expmnl = filLength;//filLength becomes the mean length for exponential polydisperse
	p = properties.find("minlength");
	assert(p != properties.end());
	expmin = atof(p->second.data());
      }
    }

    NematicProbTable npt;
    bool donem = false;
    double nematic = 0.0;
    double nemAngle = 0.0;
    std::string orientationPDF;
    p = properties.find("nematic PDF param");
    if(p != properties.end()) {
      nematic = atof(p->second.data());
      donem = true;
      p = properties.find("orientational PDF");
      if(p != properties.end()) {
	if(p->second.find("Lorentzian") != string::npos) {
	  orientationPDF = "Lorentzian";
	  npt.setPDF(1);
	  npt.setTable(nematic);
	}
	else {
	  orientationPDF = "Gaussian";
	  npt.setPDF(0);
	  npt.setTable(nematic);
	}
      }
      else {
	orientationPDF = "Gaussian";
	npt.setPDF(0);
	npt.setTable(nematic);
      }
      p = properties.find("nematic direction angle");
      if(p != properties.end()) nemAngle = atof(p->second.data());
    }

    //ranlib::Normal<double> rngps(0,sqrt(kT/kAngle));
    //rngps.seed((unsigned int)time(0));
    ranlib::Uniform<double> rnguni;
    rnguni.seed((unsigned int)time(0));
    ranlib::Exponential<double> rngexp(expmnl-expmin);
    rngexp.seed((unsigned int)time(0));

    _box = box;
    VectorND size( _box->size() );
    double vol=1.0;
    for(int i=0; i<N; i++) {
      vol *= size[i];
    }
    int nFils = (int)(filDens*vol);
    VectorND startPos;
    VectorND oldVec;
    VectorND newVec;
    double newAng;

    TempFilamentContainer tmpFils(nFils); 
    // create first and last points for each filament //

    std::cout << "Starting gel creation." << std::endl;
    for(int i=0; i<nFils; i++) {
      //rngps.seed((unsigned int)time(0)+i);
      rnguni.seed((unsigned int)time(0)+i);
      rngexp.seed((unsigned int)time(0)+i);
      double curFilLen;
      if(exponential) {
	curFilLen = rngexp.random() + expmin;
      }
      else if(longshort) {
	if(i < lsfrac*nFils) {
	  curFilLen = lsratio*filLength;
	}
	else curFilLen = filLength;
      }
      else curFilLen = filLength;
 
      TempFilament * newFil = new TempFilament();
      
      // randomly choose a starting position for the filament //	
      for(int k=0;k<N;k++) {
	newFil->start(k) = size[k]*(rnguni.random());
      }
      
      // now randomly choose an angle and an ending position //
      if(!donem) {
        newAng = 2.0*M_PI*(rnguni.random());
      }
      else {
        newAng = npt.findAngle(rnguni.random());
	if(rnguni.random() < .5) {
	  newAng = -newAng;
	}
	if(rnguni.random() < .5) {
	  newAng += M_PI;
	}
	newAng += nemAngle;
      }
      newFil->end(0) = curFilLen*cos(newAng) + newFil->start(0);
      newFil->end(1) = curFilLen*sin(newAng) + newFil->start(1);

      // determine whether filament is completely in box, crosses through two zones, or crosses through three zones //
      newFil->filSegs.push_back(pair<VectorND,VectorND>(newFil->start,newFil->end));
      if(!(_box->inside(newFil->end))) {
	VectorND newend(newFil->end);
	_box->mapPoint(newend);
	VectorND newstart;
        newstart = newend - (newFil->end - newFil->start);
	newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	if(newend(0) != newFil->end(0) && newend(1) != newFil->end(1)) {
	  newend = newFil->end;
	  _box->mapPointX(newend);
	  newstart = newend - (newFil->end - newFil->start);
	  newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	  newend = newFil->end;
	  _box->mapPointY(newend);
	  newstart = newend - (newFil->end - newFil->start);
	  newFil->filSegs.push_back(pair<VectorND,VectorND>(newstart,newend));
	}
      }

      // now look at existing filaments and find crosslink points //
      for(int j=0; j<i; j++) {
        TempFilament * oldFil = tmpFils[j];
	double oldFilLen = norm2((oldFil->end)-(oldFil->start));
	VectorND diff;
	diff = .5*((oldFil->end)+(oldFil->start)) - .5*(newFil->end+newFil->start);
	_box->mapDistance(diff);
	if(norm2(diff) <= .5*(oldFilLen+curFilLen)) {
	  VectorND intersect;
	  typename vector< pair< VectorND,VectorND > >::iterator oldFilImgs = oldFil->filSegs.begin();
	  bool connected = false;
          while(!connected && oldFilImgs!=oldFil->filSegs.end()) {
	    typename vector< pair<VectorND,VectorND> >::iterator newFilImgs = newFil->filSegs.begin();
	    while(!connected && newFilImgs!=newFil->filSegs.end()) {
	      bool checkConnect = IntersectionFinder<N>::checkIntersection(newFilImgs->first,newFilImgs->second,oldFilImgs->first,oldFilImgs->second,intersect);
	      if(checkConnect) {
	        connected = true;
		VectorND cldist;
		cldist = intersect - newFilImgs->first;
		//_box->mapDistance(cldist);
	        double distFromStart = norm2(cldist);
		cldist += newFil->filSegs[0].first;
		TempCrosslink* tmpCL = new TempCrosslink();
		tmpCL->baseFil = j;
		tmpCL->active = true;
		//tmpCL->location = intersect;
		//tmpCL->otherFils.insert(i);
		//tmpCL->otherFils.insert(j);
		tmpCL->otherFils.insert(pair< int, VectorND >(i,cldist));
	        newFil->crossFils.insert(pair<double,TempCrosslink *>(distFromStart,tmpCL));
		cldist = intersect - oldFilImgs->first;
		//_box->mapDistance(cldist);
	        distFromStart = norm2(cldist);
		cldist += oldFil->filSegs[0].first;
		tmpCL->otherFils.insert(pair< int, VectorND >(j,cldist));
	        oldFil->crossFils.insert(pair<double,TempCrosslink *>(distFromStart,tmpCL));
	      }
	      newFilImgs++;
	    }
	    oldFilImgs++;
          }
        }
      }
      tmpFils[i] = newFil;
    }


    // now iterate along each filament and find (and remove) too-short segments //
    if(removalMethod == 1) {
      int deletedCrosslinks = 0;
      deletedCrosslinks = removeCrosslinks(tmpFils,minLength);
      //for(int i=0; i<nFils; i++) {
      //deletedCrosslinks += removeCrosslinks(tmpFils[i],minLength);
      //}
      std::cout << "Removed " << deletedCrosslinks << " crosslinks from gel to avoid excessively stiff segments." << std::endl;
    }

    else if(removalMethod ==2) {
      int collapsedCrosslinks = collapseCrosslinks(tmpFils,minLength);
      std::cout << "Collapsed " << collapsedCrosslinks << " crosslinks to avoid excessively stiff segments." << std::endl;
    }

    storeSparseGel(storageFileName,tmpFils);
	
    //Disable crosslinks between two long filaments for polydispersity networks
    if(longshort && removeLngCross) {
      int deletedCrosslinks = 0;
      deletedCrosslinks = removeLongFilCrosslinks(tmpFils,filLength);
      std::cout << "Removed " << deletedCrosslinks << " crosslinks between long filaments " << std::endl;
      double averageLongFilCrosslinks;
      averageLongFilCrosslinks = computeLongFilCrosslinks(tmpFils,filLength);
      std::cout << "Average number of crosslinks on long filaments: " << averageLongFilCrosslinks << std::endl;
    }

    // we now have a list of crosslinks for each filament; we can now create the gel //
    int id = 0;
    NodeBase::DofIndexMap idx(N);
    DefNode * newNode;
    if(bondType == "Spring") {
      for(int k=0; k<nFils; k++) {
	DefNodeContainer tmpDNC;
	TempFilament * curFil = tmpFils[k];
	int nCLs = curFil->crossFils.size();
	typename multimap<double,TempCrosslink*>::iterator clIter = curFil->crossFils.begin();
	int i = 0;
	VectorND segStart;
	segStart = curFil->start;
	
	// create first node //
	for(int m=0; m<N; m++) {
	  idx[m] = N*id + m;
	}
	newNode = new BrownianNode<N>(id,idx,segStart,segStart);
	newNode->setId(id);
	tmpDNC.push_back(newNode);
	dNodes.push_back(newNode);
	id++;

	// create nodes between start and first crosslink and between all crosslink pairs //
	for(clIter; clIter!=curFil->crossFils.end(); clIter++) {
	  if(clIter->second->active) {
	    VectorND sep;
	    sep = clIter->second->otherFils[k] - segStart;
	    //_box->mapDistance(sep);
	    double dist = norm2(sep);
	    int nNodesBetween;
	    if(targetSegLength > 0.0) {
	      nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
	    }
	    else {
	      if(dist > 2.0*minLength) {
		int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
		nNodesBetween = max(1,tmpNNB);
	      }
	      else nNodesBetween = 0;
	    }
	    double segLength = dist/(nNodesBetween+1.0);
	    for(int nn=1; nn<=nNodesBetween; nn++) {
	      for(int m=0; m<N; m++) {
		idx[m] = N*id + m;
	      }
	      VectorND nodePos;
	      nodePos = segStart + nn*sep*(segLength/dist);
	      newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	      newNode->setId(id);
	      tmpDNC.push_back(newNode);
	      dNodes.push_back(newNode);
	      id++;
	    }
	    if(k == clIter->second->baseFil) {
	      for(int m=0; m<N; m++) {
		idx[m] = N*id + m;
	      }
	      VectorND nodePos;
	      nodePos = segStart + sep;
	      newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	      newNode->setId(id);
	      tmpDNC.push_back(newNode);
	      dNodes.push_back(newNode);
	      id++;
	      clIter->second->clNode = newNode;
	      //_crosslinkNodes.insert(newNode);
	      _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,newNode));
	      PeriodicTie<N> * newTie = new PeriodicTie<N>(newNode,_box);
	      addConstraint(newTie);
	      clIter->second->ptie = newTie;
	      int nSlaves = clIter->second->otherFils.size() - 1;
	      _nSlavesMap.insert(pair<DefNode*,int>(newNode,nSlaves));
	    }
	    else {
	      //newNode = clIter->second->clNode;
	      //tmpDNC.push_back(newNode);
	      //for(int m=0; m<N; m++) {
	      //  idx[m] = N*id + m;
	      //}
	      DefNode* mastNode = clIter->second->clNode;
	      VectorND nodePos;
	      nodePos = segStart + sep;
	      newNode = new BrownianNode<N>(mastNode->id(),mastNode->index(),nodePos,nodePos);
	      newNode->setId(mastNode->id());
	      tmpDNC.push_back(newNode);
	      //dNodes.push_back(newNode);
	      //id++;
	      //_crosslinkNodes.insert(newNode);
	      _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,mastNode));
	      PeriodicTie<N> * pt = clIter->second->ptie;
	      pt->addSlave(newNode);
	      
	    }
	    
	    segStart += sep;
	  }
	}

	// create nodes between last crosslink and end //	
	VectorND sep;
	sep = curFil->end - segStart;
	//_box->mapDistance(sep);
	double dist = norm2(sep);
	int nNodesBetween;
	if(targetSegLength > 0.0) {
	  nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
	}
	else {
	  if(dist > 2.0*minLength) {
	    int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	    nNodesBetween = max(1,tmpNNB);
	  }
	  else nNodesBetween = 0;
	}
	double segLength = dist/(nNodesBetween+1.0);
	for(int nn=1; nn<=nNodesBetween+1; nn++) {
	  for(int m=0; m<N; m++) {
	    idx[m] = N*id + m;
	  }
	  VectorND nodePos;
	  nodePos = segStart + nn*sep*(segLength/dist);
	  newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	  newNode->setId(id);
	  tmpDNC.push_back(newNode);
	  dNodes.push_back(newNode);
	  id++;
	}
	
	double filstrestiff = mu;
	double filbendstiff = kappa;
	
	if(longshort){
	  if(k < lsfrac*nFils) {//make long filament stiffer
	    filstrestiff = stretchstiffratio*mu;
	    filbendstiff = bendstiffratio*kappa;
	  }
	  else {
	    filstrestiff = mu;
	    filbendstiff = kappa;
	  }
	}
	addFilament(tmpDNC,filbendstiff,filstrestiff,visc,kT,dt,minLength);
	
      }
    }

    else if(bondType == "EntropicSpring") {
      
      for(int k=0; k<nFils; k++) {
	DefNodeContainer tmpDNC;
	TempFilament * curFil = tmpFils[k];
	int nCLs = curFil->crossFils.size();
	typename multimap<double,TempCrosslink*>::iterator clIter = curFil->crossFils.begin();
	int i = 0;
	VectorND segStart;
	segStart = curFil->start;
	
	// create first node //
	for(int m=0; m<N; m++) {
	  idx[m] = N*id + m;
	}
	newNode = new BrownianNode<N>(id,idx,segStart,segStart);
	newNode->setId(id);
	tmpDNC.push_back(newNode);
	dNodes.push_back(newNode);
	id++;
	
	// create nodes between start and first crosslink and between all crosslink pairs //
	for(clIter; clIter!=curFil->crossFils.end(); clIter++) {
	  if(clIter->second->active) {
	    VectorND sep;
	    sep = clIter->second->otherFils[k] - segStart;
	    //_box->mapDistance(sep);
	    double dist = norm2(sep);
	    int nNodesBetween;
	    if(targetSegLength > 0.0) {
	      nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
	    }
	    else {
	      if(dist > 2.0*minLength) {
		int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
		nNodesBetween = max(1,tmpNNB);
	      }
	      else nNodesBetween = 0;
	    }
	    double segLength = dist/(nNodesBetween+1.0);
	    for(int nn=1; nn<=nNodesBetween; nn++) {
	      for(int m=0; m<N; m++) {
		idx[m] = N*id + m;
	      }
	      VectorND nodePos;
	      nodePos = segStart + nn*sep*(segLength/dist);
	      newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	      newNode->setId(id);
	      tmpDNC.push_back(newNode);
	      dNodes.push_back(newNode);
	      id++;
	    }
	    if(k == clIter->second->baseFil) {
	      for(int m=0; m<N; m++) {
		idx[m] = N*id + m;
	      }
	      VectorND nodePos;
	      nodePos = segStart + sep;
	      newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	      newNode->setId(id);
	      tmpDNC.push_back(newNode);
	      dNodes.push_back(newNode);
	      id++;
	      clIter->second->clNode = newNode;
	      //_crosslinkNodes.insert(newNode);
	      _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,newNode));
	      PeriodicTie<N> * newTie = new PeriodicTie<N>(newNode,_box);
	      addConstraint(newTie);
	      clIter->second->ptie = newTie;
	      int nSlaves = clIter->second->otherFils.size() - 1;
	      _nSlavesMap.insert(pair<DefNode*,int>(newNode,nSlaves));
	    }
	    else {
	      //newNode = clIter->second->clNode;
	      //tmpDNC.push_back(newNode);
	      //for(int m=0; m<N; m++) {
	      //  idx[m] = N*id + m;
	      //}
	      DefNode* mastNode = clIter->second->clNode;
	      VectorND nodePos;
	      nodePos = segStart + sep;
	      newNode = new BrownianNode<N>(mastNode->id(),mastNode->index(),nodePos,nodePos);
	      newNode->setId(mastNode->id());
	      tmpDNC.push_back(newNode);
	      //dNodes.push_back(newNode);
	      //id++;
	      //_crosslinkNodes.insert(newNode);
	      _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,mastNode));
	      PeriodicTie<N> * pt = clIter->second->ptie;
	      pt->addSlave(newNode);
	      
	    }
	    
	    segStart += sep;
	  }
	}
	
	// create nodes between last crosslink and end //	
	VectorND sep;
	sep = curFil->end - segStart;
	//_box->mapDistance(sep);
	double dist = norm2(sep);
	int nNodesBetween;
	if(targetSegLength > 0.0) {
	  nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
	}
	else {
	  if(dist > 2.0*minLength) {
	    int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	    nNodesBetween = max(1,tmpNNB);
	  }
	  else nNodesBetween = 0;
	}
	double segLength = dist/(nNodesBetween+1.0);
	for(int nn=1; nn<=nNodesBetween+1; nn++) {
	  for(int m=0; m<N; m++) {
	    idx[m] = N*id + m;
	  }
	  VectorND nodePos;
	  nodePos = segStart + nn*sep*(segLength/dist);
	  newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	  newNode->setId(id);
	  tmpDNC.push_back(newNode);
	  dNodes.push_back(newNode);
	  id++;
	}
		
	addFilament(tmpDNC,kappa,mu,visc,kT,dt,minLength);
	
      }
    }

    // now that gel is set up, compute various quantities //
    
    computeCrossDistro(-1.0);

    computeFilLenDistro();

    computeFilStreStiffDistro();

    computeFilBendStiffDistro();

    computeNematicDistro(nemAngle);

    if(cutOffEnds) cutOffEndsandCCD(-1.0,dNodes);

    _output = paraview;

    for(int fn=0; fn<nFils; fn++) {
      for(typename multimap<double,TempCrosslink*>::iterator cli = tmpFils[fn]->crossFils.begin(); cli!=tmpFils[fn]->crossFils.end(); cli++) {
        if(cli->second->baseFil == fn) {
	  TempCrosslink* tmpcl = cli->second;
	  delete tmpcl;
        }  
      }	
      delete tmpFils[fn];
    }

    if(removalMethod!=2) {
      for(typename map<DefNode*,int>::iterator sn=_nSlavesMap.begin(); sn!=_nSlavesMap.end(); sn++) {
        if(sn->second != 1) std::cerr << "Error: nodes pinned incorrectly!" << std::endl;
      }
    }

    //else printCLFilDist();

    //printInitialBends();

    int nAngleSprings = 0;
    int nBonds = 0;
    int nRods = 0;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      nAngleSprings += (*fi)->angles.size();
      nBonds += (*fi)->bonds.size();
      nRods += (*fi)->rods.size();
    }
    
    std::cout << "Set up gel with " 
	      << nFils << " filaments, " 
	      << nAngleSprings << " angle springs, "
	      << nBonds << " bonds, and "
	      << nRods << " brownian rods."
	      << std::endl;

  }

  template<int N>
  SemiflexibleGel<N>::SemiflexibleGel(std::string fileName, DefNodeContainer & dNodes, std::string bondType, bool cutOffEnds, double minLength, const PropertyList & properties) {
    ConstPropertyIterator p = properties.find("kT");
    assert( p != properties.end() );
    double kT = atof(p->second.data());

    p = properties.find("angle stiffness");
    assert( p != properties.end() );
    double kappa = atof(p->second.data());

    p = properties.find("bond stiffness");
    assert(p != properties.end());
    double mu = atof(p->second.data());

    p = properties.find("viscosity");
    assert( p != properties.end() );
    double visc = atof(p->second.data());

    p = properties.find("time step");
    assert( p != properties.end() );
    double dt = atof(p->second.data());

    p = properties.find("L");
    assert( p != properties.end() );
    double filLength = atof(p->second.data());


    // removalMethod key: 0 = stretch short segments; 1 = delete one in each pair; 2 = collapse nodes //
    int removalMethod = 0;	

    double targetSegLength;
    p = properties.find("target segment length");
    if(p != properties.end()) {
      targetSegLength = atof(p->second.data());
    }
    else targetSegLength = 2.0*minLength;
    //assert(targetSegLength > 0.0);
    //assert(targetSegLength > minLength);

    double nemAngle = 0.0;
    p = properties.find("nematic direction angle");
    if(p != properties.end()) nemAngle = atof(p->second.data());
    
    //need to read in stiffratio because it's not stored
    double stretchstiffratio = 1.0;
    double bendstiffratio = 1.0;
    double lsfrac = -1.0;
    std::string polydispStr;
    bool longshort = false;
    bool removeLngCross = false;
    p = properties.find("polydispersity");
    if(p != properties.end()) {
      polydispStr.assign(p->second);
      if(polydispStr.find("LongShort") != string::npos) {
	longshort = true;
	p = properties.find("longfraction");
	assert(p != properties.end());
	lsfrac = atof(p->second.data());
	assert(lsfrac <= 1.0);
	p = properties.find("stretchstiffratio");
	assert(p != properties.end());
	stretchstiffratio = atof(p->second.data());
	p = properties.find("bendstiffratio");
	assert(p != properties.end());
        bendstiffratio = atof(p->second.data());
	p = properties.find("removelongcrosslink");
	assert(p != properties.end());
	if(atof(p->second.data())> 0.5) removeLngCross = true;
	else removeLngCross = false;
      }
      else if(polydispStr.find("Exponential") != string::npos){
	//Don't have to do anything, all fil info are to be read in
	std::cout << "Exponential polydispersity: Filaments info will be read in ......" << std::endl;
      }
    }

    int intSize = sizeof(int);
    int doubleSize = sizeof(double);

    // open the file at the end to get size //
    std::ifstream inFile(fileName.data(), ios::in | ios::binary | ios::ate);
    ifstream::pos_type fsize = inFile.tellg();
    
    // reset file to beginning //
    inFile.seekg(0,ios::beg);
    
    // read in system size and set up PeriodicBox //
    VectorND sysSize;
    for(int i=0; i<N; i++) {
      double curSS;
      inFile.read((char *)(&curSS),doubleSize);
      sysSize[i] = curSS;
    }
    PeriodicBox * box = new LeesEdwards(sysSize[0],sysSize[1],0.0);
    //box->setShear(0.0);
    setBox(box);
    
    // read in # of filaments
    int nFils;
    inFile.read((char *)(&nFils),intSize);
    TempFilamentContainer tmpFils(nFils);
    for(int i=0; i<nFils; i++) {
      VectorND start;
      VectorND end;
      for(int j=0; j<N; j++) {
	double curp;
	inFile.read((char *)(&curp),doubleSize);
	start[j] = curp;
      } 
      for(int j=0; j<N; j++) {
	double curp;
	inFile.read((char *)(&curp),doubleSize);
	end[j] = curp;
      }
      TempFilament* tf = new TempFilament();
      tf->start = start;
      tf->end = end;
      tmpFils[i] = tf; 	
    }
    int nCLs;
    inFile.read((char *)(&nCLs),intSize);
    for(int i=0; i<nCLs; i++) {
      TempCrosslink* cl = new TempCrosslink();
      cl->active = true;
      int nCLsHere;
      inFile.read((char *)(&nCLsHere),intSize);
      for(int nc=0; nc<nCLsHere; nc++) {
        int filnum;
        inFile.read((char *)(&filnum),intSize);
	VectorND cllocalpos;
	for(int j=0; j<N; j++) {
	  double curp;
	  inFile.read((char *)(&curp),doubleSize);
	  cllocalpos[j] = curp;
	}
	cl->otherFils.insert(pair< int, VectorND >(filnum,cllocalpos));
      }
      typename map< int, VectorND >::iterator cfs = cl->otherFils.begin();
      cl->baseFil = cfs->first;
      //VectorND loc;
      //for(int j=0; j<N; j++) {
      //double curp;
      //inFile.read((char *)(&curp),doubleSize);
      //loc[j] = curp;
      //}
      //cl->location = loc;
      for(cfs; cfs!=cl->otherFils.end(); cfs++) {
        VectorND start1;
	start1 = tmpFils[cfs->first]->start;
	VectorND sep1;
	sep1 = cfs->second - start1;
	//_box->mapDistance(sep1);
	double dist1;
	dist1 = norm2(sep1);
	tmpFils[cfs->first]->crossFils.insert(pair<double,TempCrosslink*>(dist1,cl));
      }
    }

    inFile.close();
    std::cout << "Finished reading data on " << nFils << " filaments and " << nCLs << " crosslinks from file " << fileName << "; creating gel." << std::endl;

    //Disable crosslinks between two long filaments for polydispersity networks
    if(longshort && removeLngCross) {
      int deletedCrosslinks = 0;
      deletedCrosslinks = removeLongFilCrosslinks(tmpFils,filLength);
      std::cout << "Removed " << deletedCrosslinks << " crosslinks between long filaments " << std::endl;
      double averageLongFilCrosslinks;
      averageLongFilCrosslinks = computeLongFilCrosslinks(tmpFils,filLength);
      std::cout << "Average number of crosslinks on long filaments: " << averageLongFilCrosslinks << std::endl;
    }

    // we now have a list of crosslinks for each filament; we can now create the gel //
    int id = 0;
    NodeBase::DofIndexMap idx(N);
    DefNode * newNode;	
    for(int k=0; k<nFils; k++) {
      DefNodeContainer tmpDNC;
      TempFilament * curFil = tmpFils[k];
      int nCLs = curFil->crossFils.size();
      typename multimap<double,TempCrosslink*>::iterator clIter = curFil->crossFils.begin();
      int i = 0;
      VectorND segStart;
      segStart = curFil->start;

      // create first node //
      for(int m=0; m<N; m++) {
        idx[m] = N*id + m;
      }
      newNode = new BrownianNode<N>(id,idx,segStart,segStart);
      newNode->setId(id);
      tmpDNC.push_back(newNode);
      dNodes.push_back(newNode);
      id++;

      // create nodes between start and first crosslink and between all crosslink pairs //
      for(clIter; clIter!=curFil->crossFils.end(); clIter++) {
	if(clIter->second->active) {
	  VectorND sep;
	  sep = clIter->second->otherFils[k] - segStart;
	  //_box->mapDistance(sep);
	  double dist = norm2(sep);
	  int nNodesBetween;
	  if(targetSegLength > 0.0) {
            nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
          }
          else {
            if(dist > 2.0*minLength) {
              int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	      nNodesBetween = max(1,tmpNNB);
            }
            else nNodesBetween = 0;
          }
      	  double segLength = dist/(nNodesBetween+1.0);
          for(int nn=1; nn<=nNodesBetween; nn++) {
            for(int m=0; m<N; m++) {
	      idx[m] = N*id + m;
            }
	    VectorND nodePos;
	    nodePos = segStart + nn*sep*(segLength/dist);
            newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	    newNode->setId(id);
	    tmpDNC.push_back(newNode);
	    dNodes.push_back(newNode);
	    id++;
          }
	  if(k == clIter->second->baseFil) {
            for(int m=0; m<N; m++) {
	      idx[m] = N*id + m;
            }
	    VectorND nodePos;
	    nodePos = segStart + sep;
	    newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	    newNode->setId(id);
	    tmpDNC.push_back(newNode);
	    dNodes.push_back(newNode);
	    id++;
	    clIter->second->clNode = newNode;
	    //_crosslinkNodes.insert(newNode);
	    _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,newNode));
            PeriodicTie<N> * newTie = new PeriodicTie<N>(newNode,_box);
	    addConstraint(newTie);
	    clIter->second->ptie = newTie;
	    int nSlaves = clIter->second->otherFils.size() - 1;
	    _nSlavesMap.insert(pair<DefNode*,int>(newNode,nSlaves));
	  }
	  else {
	    //newNode = clIter->second->clNode;
	    //tmpDNC.push_back(newNode);
	    //for(int m=0; m<N; m++) {
	    //  idx[m] = N*id + m;
            //}
	    DefNode* mastNode = clIter->second->clNode;
	    VectorND nodePos;
	    nodePos = segStart + sep;
	    newNode = new BrownianNode<N>(mastNode->id(),mastNode->index(),nodePos,nodePos);
	    newNode->setId(mastNode->id());
	    tmpDNC.push_back(newNode);
            //dNodes.push_back(newNode);
	    //id++;
	    //_crosslinkNodes.insert(newNode);
	    _crossNodeMap.insert(pair<DefNode*,DefNode*>(newNode,mastNode));
	    PeriodicTie<N> * pt = clIter->second->ptie;
            pt->addSlave(newNode);

	  }
	  
	  segStart += sep;
	}
      }

      // create nodes between last crosslink and end //	
      VectorND sep;
      sep = curFil->end - segStart;
      //_box->mapDistance(sep);
      double dist = norm2(sep);
      int nNodesBetween;
      if(targetSegLength > 0.0) {
	nNodesBetween = (int)(std::floor((dist/targetSegLength)) -.5);
      }
      else {
	if(dist > 2.0*minLength) {
	  int tmpNNB = (int)(std::floor((dist/fabs(targetSegLength))) -.5);
	  nNodesBetween = max(1,tmpNNB);
	}
	else nNodesBetween = 0;
      }

      double segLength = dist/(nNodesBetween+1.0);
      for(int nn=1; nn<=nNodesBetween+1; nn++) {
        for(int m=0; m<N; m++) {
	  idx[m] = N*id + m;
        }
	VectorND nodePos;
	nodePos = segStart + nn*sep*(segLength/dist);
        newNode = new BrownianNode<N>(id,idx,nodePos,nodePos);
	newNode->setId(id);
	tmpDNC.push_back(newNode);
	dNodes.push_back(newNode);
	id++;
      }
      
      double filstrestiff = mu;
      double filbendstiff = kappa;
      if(bondType == "Spring") {
	if(longshort) {
	  if(k < lsfrac*nFils) {//make long filament stiffer
	    filstrestiff = stretchstiffratio*mu;
	    filbendstiff = bendstiffratio*kappa;
	  }
	  else {
	    filstrestiff = mu;
	    filbendstiff = kappa;
	  }
	}
	addFilament(tmpDNC,filbendstiff,filstrestiff,visc,kT,dt,minLength);
      }

      else std::cout << "Adaptive meshing with nonlinear springs not implemented yet!" << std::endl;

    }

    // now that gel is set up, compute various quantities //
    
    computeCrossDistro(-1.0);

    computeFilLenDistro();

    computeFilStreStiffDistro();

    computeFilBendStiffDistro();

    computeNematicDistro(nemAngle);

    if(cutOffEnds) cutOffEndsandCCD(-1.0,dNodes);

    _output = paraview;

    for(int fn=0; fn<nFils; fn++) {
      for(typename multimap<double,TempCrosslink*>::iterator cli = tmpFils[fn]->crossFils.begin(); cli!=tmpFils[fn]->crossFils.end(); cli++) {
        if(cli->second->baseFil == fn) {
	  TempCrosslink* tmpcl = cli->second;
	  delete tmpcl;
        }  
      }	
      delete tmpFils[fn];
    }

    if(removalMethod!=2) {
      for(typename map<DefNode*,int>::iterator sn=_nSlavesMap.begin(); sn!=_nSlavesMap.end(); sn++) {
        if(sn->second != 1) std::cerr << "Error: nodes pinned incorrectly!" << std::endl;
      }
    }

    //else printCLFilDist();

    //printInitialBends();

    int nAngleSprings = 0;
    int nBonds = 0;
    int nRods = 0;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      nAngleSprings += (*fi)->angles.size();
      nBonds += (*fi)->bonds.size();
      nRods += (*fi)->rods.size();
    }
    
    std::cout << "Set up gel with " 
	      << nFils << " filaments, " 
	      << nAngleSprings << " angle springs, "
	      << nBonds << " bonds, and "
	      << nRods << " brownian rods."
	      << std::endl;

  }
 
  // Construct a filament with linear springs
  template<int N>
  SemiflexibleGel<N>::Filament::Filament( const DefNodeContainer & n, 
					  double kBond, double kAngle,
					  double viscosity, double kT, double dt) 
    : nodes(n) {
    
    for( int i=0; i<nodes.size()-1; i++ ) {
      // create Bonds and Rods
      //
      // i -- i+1 
      //
      Bond * b = new Bond( nodes[i], nodes[i+1], kBond ) ;
      bonds.push_back(b);
      Rod * r = new Rod( nodes[i], nodes[i+1], viscosity, kT, dt ) ;
      rods.push_back(r);

    }
    
    for( int i=0; i<nodes.size()-2; i++ ) {
      // create Angles
      //
      // i         i+2 
      //   \     /
      //     i+1	  
      Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
      angles.push_back(a);
    }	
  }

  // construct a filament with nonlinear (entropic) springs
  template<int N>
  SemiflexibleGel<N>::Filament::Filament( const DefNodeContainer & n, double kAngle, 
					  double viscosity, double kT, double dt, 
					  double kC, int fitOrder, double maxForce) 
    : nodes(n) {
    
    double Lp = kC/kT;
    double L0 = norm2(nodes[0]->point()-nodes[1]->point());
    double Larc = (nodes.size()-1)*L0*(1.0+(L0/(6.0*Lp)));
    for( int i=0; i<nodes.size()-1; i++ ) {
      // create Bonds and Rods
      //
      // i -- i+1 
      // 
      Bond * b = new EntropicSpring<N>( nodes[i], nodes[i+1], kT, kC, fitOrder, nodes.size()-1, Larc, true, maxForce ) ;
      bonds.push_back(b);
      Rod * r = new Rod( nodes[i], nodes[i+1], viscosity, kT, dt ) ;
      rods.push_back(r);

    }
    
    for( int i=0; i<nodes.size()-2; i++ ) {
      // create Angles
      //
      // i         i+2 
      //   \     /
      //     i+1	  
      Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
      angles.push_back(a);
    }	
  }

  // construct a filament with different segment lengths //
  template<int N>
  SemiflexibleGel<N>::Filament::Filament(const DefNodeContainer & n, double kappa, double mu, double viscosity, double kT, double dt, double minLength) : nodes(n) {
    int stretchedSegs = 0;
    if(nodes.size()>1) {
      for( int i=0; i<nodes.size()-1; i++ ) {
	// create Bonds and Rods
	//
	// i -- i+1 
	//
	VectorND bondSep;
	bondSep = nodes[i+1]->position() - nodes[i]->position();
	//box->mapDistance(bondSep);
	double bondLength = norm2(bondSep);
	if(bondLength < minLength) {
	  bondLength = minLength;
	  stretchedSegs++;
	}
	double kBond = mu/bondLength;
	Bond * b = new Bond( nodes[i], nodes[i+1], kBond, bondLength ) ;
	bonds.push_back(b);
	Rod * r = new Rod( nodes[i], nodes[i+1], viscosity, kT, dt, bondLength ) ;
	rods.push_back(r);
	
	//std::cout << "Warning: stretched " << stretchedSegs << " filament segments to avoid excessive stiffness." << std::endl;
	
      }
    }
    if(nodes.size()>2) {
      for( int i=0; i<nodes.size()-2; i++ ) {
	// create Angles
	//
	// i         i+2 
	//   \     /
	//     i+1	  
	VectorND segSep1;
	VectorND segSep2;
	segSep1 = nodes[i+2]->position() - nodes[i+1]->position();
	segSep2 = nodes[i+1]->position() - nodes[i]->position();
	//box->mapDistance(segSep1);
	//box->mapDistance(segSep2);
	double segLength1 = norm2(segSep1);
	double segLength2 = norm2(segSep2);
	if(segLength1 < minLength) {
	  segLength1 = minLength;
	}
	if(segLength2 < minLength) {
	  segLength2 = minLength;
	}
	double avgLength = .5*(segLength1+segLength2);
	double kAngle = kappa/avgLength;
	Angle * a = new Angle( nodes[i], nodes[i+1], nodes[i+2], kAngle );
	angles.push_back(a);
      }	
    }
  }

  template<int N>
  SemiflexibleGel<N>::Filament::~Filament() {
    for(int i=0; i< bonds.size(); i++) delete( bonds[i]);
    for(int i=0; i<  rods.size(); i++) delete(  rods[i]);
    for(int i=0; i<angles.size(); i++) delete(angles[i]);
  }

  template<int N>
  const typename tvmet::Vector<double,N> & SemiflexibleGel<N>::Filament::point() {
    int nNodes = nodes.size();
    pt = nodes[0]->point() + nodes[nNodes-1]->point();
    pt /= 2.0;
    return pt;
  }

  template<int N>
  void SemiflexibleGel<N>::removePrestress() {
    // first, set nodal positions so that crosslinked nodes lie on top of one another //
    for(ConstraintIterator c=_constraints.begin(); c!=_constraints.end(); c++) {
      (*c)->predict();
    }
    // now reset reference lengths and stiffnesses of springs and angle springs //
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(BondIterator bi=(*fi)->bonds.begin(); bi!=(*fi)->bonds.end(); bi++) {
	double oldd = (*bi)->getLength();
	(*bi)->resetLength();
	double newd = (*bi)->getLength();
	// do not allow segments to get too short //
	if(newd <= 5.0e-3) {
	  (*bi)->resetLength(5.0e-3);
	  newd = 5.0e-3;
	  std::cout << "Found short segment!" << std::endl;
	}
	double ksp = (*bi)->stiffness();
	(*bi)->setStiffness(ksp*oldd/newd);
      }
      for(AngleIterator ai=(*fi)->angles.begin(); ai!=(*fi)->angles.end(); ai++) {
	double oldL = (*ai)->meanSegmentLength();
	double newL = (*ai)->meanSegmentExtension();
	double kang = (*ai)->stiffness();
	if(newL <= 5.0e-3) {
	  newL = 5.0e-3;
	  std::cout << "Found short segments!" << std::endl;
	}
	(*ai)->setStiffness(kang*oldL/newL);
      }
    }
  }

  template<int N>
  int SemiflexibleGel<N>::removeCrosslinks(TempFilamentContainer & tmpFils, double minLength) {
    int deletedCrosslinks = 0;
    ranlib::Uniform<double> rnguni;
    rnguni.seed((unsigned int)time(0));
    int nf;
    for(nf=0; nf<tmpFils.size(); nf++) {
      TempFilament* fil = tmpFils[nf];
      typename multimap<double,TempCrosslink*>::iterator clIter = fil->crossFils.begin();
      vector<TempCrosslink*> cls;
      for(clIter; clIter!=fil->crossFils.end(); clIter++) {
	if(clIter->second->active) {
	  cls.push_back(clIter->second);
	}
      }
      int nCL = cls.size();
      int i = 0;
      while(i<nCL-1) {
	int j=i+1;
	while(j<nCL && cls[j]->active == false) j++;
	if(j<nCL) {
	  rnguni.seed((unsigned int)(time(0)+j));
	  VectorND clSep;
	  clSep = cls[j]->otherFils[nf] - cls[i]->otherFils[nf];
	  //_box->mapDistance(clSep);
	  double clDist = norm2(clSep);
	  if(clDist < minLength) {
	    // randomly select one of the crosslinks to remove //
	    if(rnguni.random() < .5) {
	      cls[i]->active = false;
	      i = j;	    
	    }
	    else {
	      cls[j]->active = false;
	    }
	    deletedCrosslinks++;
	  }
	  else i = j;
	}
	else i = j;
      }
    }

    return deletedCrosslinks;  
  }

  template<int N>
  int SemiflexibleGel<N>::removeLongFilCrosslinks(TempFilamentContainer & tmpFils, double L) {
    int deletedCrosslinks = 0;
    //ranlib::Uniform<double> rnguni;
    //rnguni.seed((unsigned int)time(0));
    int nf;
    for(nf=tmpFils.size()-1;nf>-1 ;nf--) {
      TempFilament* fil = tmpFils[nf];
      double filLen = norm2((fil->end)-(fil->start));
      if(filLen > 1.2*L) {
	typename multimap<double,TempCrosslink*>::iterator clIter = fil->crossFils.begin();
	vector<TempCrosslink*> cls;
	for(clIter; clIter!=fil->crossFils.end(); clIter++) {
	  if(clIter->second->active) {
	    cls.push_back(clIter->second);
	  }
	}
	for(int i=0;i<cls.size();i++) {
	  int j=cls[i]->baseFil;
	  if(j<nf) { //a untested filament
	    TempFilament* fil2 = tmpFils[j];
	    double filLen2 = norm2((fil2->end)-(fil2->start));
	    if (filLen2 > 1.2*L) {
	      cls[i]->active = false;
	      deletedCrosslinks++;
	    }
	  }
	}
      }
    }
    //output long filaments average crosslinks
    return deletedCrosslinks;  
  }

  template<int N>
  double SemiflexibleGel<N>::computeLongFilCrosslinks(TempFilamentContainer & tmpFils, double L) {
    //output long filaments average crosslinks
    int averageCrosslinks = 0;
    int nf;
    int numberofLong = 0;
    int numberofLongCL = 0;
    for(nf=tmpFils.size()-1;nf>-1 ;nf--) {
      TempFilament* fil = tmpFils[nf];
      double filLen = norm2((fil->end)-(fil->start));
      if(filLen > 1.2*L) {
	numberofLong++;
	typename multimap<double,TempCrosslink*>::iterator clIter = fil->crossFils.begin();
	vector<TempCrosslink*> cls;
	for(clIter; clIter!=fil->crossFils.end(); clIter++) {
	  if(clIter->second->active) {
	    numberofLongCL++;
	  }
	}
      }
    }
    double averageLongFilCL = double(numberofLongCL)/double(numberofLong);
    return averageLongFilCL;
  }

  template<int N>
  int SemiflexibleGel<N>::collapseCrosslinks(TempFilamentContainer & tmpFils, double minLength) {
//     // collapse crosslinks to avoid short segments //
//     VectorND size;
//     size = _box->size();
//     int nIn = (int)(floor(size[0]/minLength)+.5);
//     bool fit = false;
//     double boxSize;
//     while(!fit) {
//       boxSize = size[0]/nIn;
//       fit = true;
//       for(int i=0; i<N; i++) {
//         if(fmod(size[0],boxSize) > 1.0e-6) fit = false;
//       }
//       nIn--;
//     }
//     for(int i=0; i<N; i++) assert(fmod(size[i],boxSize) < 1.0e-6);
//     int nx = (int)((size[0]/boxSize)+.5);
//     int ny = (int)((size[1]/boxSize)+.5);
    
//     TempBox** boxes = new TempBox*[nx];
//     for(int xbox=0; xbox<nx; xbox++) {
//       TempBox* newBox = new TempBox[ny];
//       boxes[xbox] = newBox;
//     }
//     int nFils = tmpFils.size();
//     for(int i=0; i<nFils; i++) {
//       TempFilament* fi = tmpFils[i];
//       for(typename multimap<double,TempCrosslink*>::iterator cl=fi->crossFils.begin(); cl!=fi->crossFils.end(); cl++) {
//         if(cl->second->baseFil == i) {
//           VectorND & pos = cl->second->location;
//           int xpos = (int)(floor(pos[0]/boxSize)+.5);
// 	  int ypos = (int)(floor(pos[1]/boxSize)+.5);
// 	  boxes[xpos][ypos].boxCLs.push_back(cl->second);
//         }
//       }
//       fi->crossFils.clear();
//     }

//     // now look for clusters to collapse //
//     int nCollapsed = 0;
//     for(int i=0; i<nx; i++) {
//       for(int j=0; j<ny; j++) {
//         int nBoxCLs = boxes[i][j].boxCLs.size();
// 	for(int m=0; m<nBoxCLs; m++) {
// 	  TempCrosslink* cl = boxes[i][j].boxCLs[m];
//           if(cl->active) {
//             // look for in-box neighbors //
// 	    int nCollapsedHere = 1;
// 	    VectorND center(0.0);
// 	    for(int n=m+1; n<nBoxCLs; n++) {
//               TempCrosslink* cl2 = boxes[i][j].boxCLs[n];
// 	      if(cl2->active) {
//                 VectorND diff;
//                 diff = cl->location - cl2->location;
// 		bool sameFil = false;
// 		typename set<int>::iterator fs1 = cl->otherFils.begin();
// 		while(!sameFil && fs1!=cl->otherFils.end()) {
// 		  if(cl2->otherFils.find(*fs1) != cl2->otherFils.end()) sameFil = true;
// 		  fs1++;
// 		}
//                 if(norm2(diff) < minLength && sameFil) {
//                   center += diff;
// 		  nCollapsedHere++;
// 		  nCollapsed++;
// 		  cl2->active = false;
// 		  typename set<int>::iterator fs2 = cl2->otherFils.begin();
// 		  for(fs2; fs2!=cl2->otherFils.end(); fs2++) {
// 		    cl->otherFils.insert(*fs2);
//                   }
// 		  typename set<int>::iterator fb = cl->otherFils.begin();
// 		  cl->baseFil = *fb;
// 	 	}
//               }
//             }
// 	    // look at other boxes //
// 	    for(int di=-1; di<=1; di++) {
//               for(int dj=-1; dj<=1; dj++) {
//                 int ip = (i+di+nx)%nx;
// 		int jp = (j+dj+ny)%ny;
// 		if(ip!=i || jp!=j) {
//                   int nBoxCLs2 = boxes[ip][jp].boxCLs.size();
// 		  for(int p=0; p<nBoxCLs2; p++) {
// 		    TempCrosslink* cl2 = boxes[ip][jp].boxCLs[p];
// 		    if(cl2->active) {
// 	              VectorND diff;
// 		      diff = cl->location - cl2->location;
// 		      _box->mapDistance(diff);
//                       bool sameFil = false;
//                       typename set<int>::iterator fs1 = cl->otherFils.begin();
// 		      while(!sameFil && fs1!=cl->otherFils.end()) {
// 		        if(cl2->otherFils.find(*fs1) != cl2->otherFils.end()) sameFil = true;
// 		        fs1++;
// 		      }
//                       if(norm2(diff) < minLength && sameFil) {
//                         center += diff;
//                         nCollapsedHere++;
// 			nCollapsed++;
// 			cl2->active = false;
// 		        typename set<int>::iterator fs2 = cl2->otherFils.begin();
// 		        for(fs2; fs2!=cl2->otherFils.end(); fs2++) {
// 		          cl->otherFils.insert(*fs2);
//                         }
// 		        typename set<int>::iterator fb = cl->otherFils.begin();
// 		        cl->baseFil = *fb;
			
//                       }
//                     }    
//                   }
//                 }
//               }
//             }
// 	    // having collapsed, reset position and baseFil //
//             center /= nCollapsedHere;
// 	    center += cl->location;
// 	    _box->mapPoint(center);
// 	    cl->location = center; 
//           }
//         } 
//       }
//     }
    
//     for(int i=0; i<nx; i++) {
//       for(int j=0; j<ny; j++) {
//         typename vector<TempCrosslink *>::iterator cls = boxes[i][j].boxCLs.begin();
// 	for(cls; cls!=boxes[i][j].boxCLs.end(); cls++) {
// 	  if((*cls)->active) {
// 	    typename set<int>::iterator cl = (*cls)->otherFils.begin();
// 	    for(cl; cl!=(*cls)->otherFils.end(); cl++) {
//               VectorND filStart;
//               filStart = tmpFils[*cl]->start;
// 	      VectorND sep;
// 	      sep = (*cls)->location - filStart;
// 	      _box->mapDistance(sep);
// 	      tmpFils[*cl]->crossFils.insert(pair<double,TempCrosslink*>(norm2(sep),*cls));
//             }
//           }
// 	  else delete *cls;  
//         }
//       }
//     }

//     return nCollapsed;

    return 0;
  }

  template<int N>
  void SemiflexibleGel<N>::moveCLNodes(Filament * f) {
    int nNodes = f->nodes.size();
    int dn = 0;
    while(_crosslinkNodes.find(f->nodes[dn]) != _crosslinkNodes.end()) dn++;
    assert(dn<nNodes);
    VectorND ref;
    ref = f->nodes[dn]->point();
    for(dn = 0; dn<nNodes; dn++) {     
      if(_crosslinkNodes.find(f->nodes[dn]) != _crosslinkNodes.end()) {
        VectorND diff;
        diff = f->nodes[dn]->point() - ref;
	_box->mapDistance(diff);
	diff += ref;
	f->nodes[dn]->setPoint(diff);
      } 
    }
  }

  template<int N>
  void SemiflexibleGel<N>::compute( bool f0, bool f1, bool f2 ) {

    // Predictor/corrector approach for constraint
    int nConstraints = _constraints.size();

#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
    {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait
#endif
      for(int ic=0; ic<nConstraints; ic++) {
	// if(ic%1000==0) std::cout << "predicting with constraint " << ic << std::endl;
	_constraints[ic]->predict();
      }
    } 

    if( f0 ) _energy = 0.0;
    
    // compute energy and forces
    int nFils = _filaments.size();

#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
    {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait
#endif
      for(int i=0; i<nFils; i++) {
	// if(i%1000==0) std::cout << "computing on filament " << i << std::endl;
	Filament * f= filament(i);
	//moveCLNodes(f);
	for( BondIterator b = f->bonds.begin(); b!= f->bonds.end(); b++ ) {
	  (*b)->compute(f0,f1,f2);
	}
	// No brownian rod implemented in the semiflexible gel simulation
//	for( RodIterator r = f->rods.begin(); r!= f->rods.end(); r++ ) {
//        (*r)->compute(f0,f1,f2);
//      }
	for( AngleIterator a = f->angles.begin(); a!= f->angles.end(); a++ ) {
	  (*a)->compute(f0,f1,f2);
	}
      }
    }   

    for( CrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++) {
      (*c)->compute(f0,f1,f2);
    }

    for( MotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
      if((*m)->isAttached()) (*m)->compute(f0,f1,f2);
    }

    for(PinchIterator p=_pinches.begin(); p!=_pinches.end(); p++) {
      (*p)->compute(f0,f1,f2);
    }

    int ntbp = _tbp.size();
    double tbpenergy = 0.0;
    if(ntbp!=0) {
      std::map< Filament*,std::set<Filament*> > & filpairs = _grid->getNeighbors();
      for(typename std::map< Filament*,std::set<Filament*> >::iterator fp = filpairs.begin(); fp!=filpairs.end(); fp++) {
	Filament* fil1 = fp->first;
	for(typename std::set<Filament*>::iterator partners=fp->second.begin(); partners!=fp->second.end(); partners++) {
	  Filament* fil2 = *partners;
	  if(fil1<fil2) {
	    for(int tb=0; tb<ntbp; tb++) {
	      tbpenergy += _tbp[tb]->compute(fil1->nodes,fil2->nodes,f0,f1,f2);
	    }
	  }
	}
      }
    }
    //checkParallelForces();
    
    // sum energy
    if( f0 ) {
      double tmpenergy = 0.0;
#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
      {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait reduction(+:tmpenergy)
#endif
	for(int i=0; i<nFils; i++) {
	  // if(i%1000==0) std::cout << "computing on filament " << i << std::endl;
	  Filament * f = filament(i);
	  for( BondIterator b = f->bonds.begin(); b!= f->bonds.end(); b++ ) {
	    tmpenergy += (*b)->energy();
	  }
	  for( AngleIterator a = f->angles.begin(); a!= f->angles.end(); a++ ) {
	    tmpenergy += (*a)->energy();
	  }
	}
      }
      
      for(CrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++) {
        tmpenergy += (*c)->energy();
      }
      for(PinchIterator p=_pinches.begin(); p!=_pinches.end(); p++) {
	tmpenergy += (*p)->energy();
      }
      _energy = tmpenergy + tbpenergy;
    } 

    // Predictor/corrector approach for constraint

#ifdef _OPENMP	
#pragma omp parallel default(shared)
#endif
    {
#ifdef _OPENMP
#pragma omp for schedule(static) nowait
#endif
      for(int ic=0; ic<nConstraints; ic++) {
	_constraints[ic]->correct();
      }
    }

  }

  template<int N>
  void SemiflexibleGel<N>::printParaview(const std::string name) const {

//     //     std::cout << "SemiflexibleGel<N>::printParaview()." << std::endl;
//     //
//     // open file
//     //
//     std::string fileName = name + ".vtk";
//     std::ofstream ofs(fileName.c_str());
//     if (!ofs) {
//       std::cout << "Error: can not open paraview output file "
// 		<< fileName
// 		<< std::endl;
//       return;
//     }
    
//     //
//     //    Node position data
//     //
    
//     std::map<DefNode*,int> nodeIDMap;
//     std::vector<DefNode*> printNodes;
//     std::set<DefNode*> imageNodes;
//     std::vector< std::pair<DefNode*,DefNode*> > mainPairs;
//     std::vector< std::pair<DefNode*,DefNode*> > imgPairs;
//     int nodeCount = 0;

//     //double shear = _box->shear();
//     double shear = 0.0;
//     _box->setShear(0.0);
//     int nodeID = 0;
//     for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
//       Filament* f1 = *fi;
//       int nfNodes = f1->nodes.size();
//       for(int nn=0; nn<nfNodes-1; nn++) {
// 	VectorND mapPos1;
// 	mapPos1 = f1->nodes[nn]->position();
// 	_box->mapPoint(mapPos1);
// // 	VectorND def1;
// // 	def1 = f1->nodes[nn]->point() - mapPos1;
// // 	_box->setShear(shear);
// // 	_box->mapDistance(def1);
// // 	_box->setShear(0.0);
// // 	def1 += mapPos1;
// // 	DefNode* newNode1 = new BrownianNode<2>(nodeID,f1->nodes[nn]->index(),mapPoint,def1);
// 	nodeIDMap.insert(pair<DefNode*,int>(f1->nodes[nn],nodeID));
// 	nodeID++;
// 	nodeCount++;
// 	printNodes.push_back(f1->nodes[nn]);
// 	VectorND mapPos2;
// 	mapPos2 = f1->nodes[nn+1]->position();
// 	_box->mapPoint(mapPos2);
// 	VectorND diff;
// 	diff = mapPos2 - mapPos1;
// 	double candist = norm2(diff);
// 	_box->mapDistance(diff);
// 	double dist = norm2(diff);
// 	// if bond crosses boundary, make image nodes //
// 	if(fabs(dist-candist) > 1.0e-6) {
// 	  VectorND img1pos;
// 	  img1pos = mapPos2 - diff;
// 	  VectorND disp;
// 	  disp = f1->nodes[nn]->point() - img1pos;
// 	  _box->setShear(shear);
// 	  _box->mapDistance(disp);
// 	  _box->setShear(0.0);
// 	  disp += img1pos;
// 	  DefNode* imgNode1 = new BrownianNode<2>(nodeID,f1->nodes[nn]->index(),img1pos,disp);
// 	  nodeIDMap.insert(pair<DefNode*,int>(imgNode1,nodeID));
// 	  nodeID++;
// 	  nodeCount++;
// 	  printNodes.push_back(imgNode1);
// 	  imageNodes.insert(imgNode1);
// 	  imgPairs.insert(pair<DefNode*,DefNode*>(imgNode1,f1->nodes[nn+1]));
// 	  VectorND img2pos;
// 	  img2pos = mapPos1 + diff;
// 	  VectorND disp2;
// 	  disp2 = f1->nodes[nn+1]->point() - img2pos;
// 	  _box->setShear(shear);
// 	  _box->mapDistance(disp2);
// 	  _box->setShear(0.0);
// 	  disp2 += img2pos;
// 	  DefNode* imgNode2 = new BrownianNode<2>(f1->nodes[nn+1]->id(),f1->nodes[nn+1]->index(),img2pos,disp2);
// 	  nodeIDMap.insert(pair<DefNode*,int>(imgNode2,nodeID));
// 	  nodeID++;
// 	  nodeCount++;
// 	  printNodes.push_back(imgNode2);
// 	  imageNodes.insert(imgNode2);
// 	  mainPairs.insert(pair<DefNode*,DefNode*>(f1->nodes[nn],imgNode2));
// 	}
// 	// if not, just add node pair //
// 	else {
// 	  mainPairs.insert(pair<DefNode*,DefNode*>(f1->nodes[nn],f1->nodes[nn+1]));
// 	}
//       }
//       // now add last node //
//       nodeIDMap.insert(pair<DefNode*,int>(f1->nodes[nfNodes-1],nodeID));
//       nodeID++;
//       nodeCount++;
//       printNodes.push_back(f1->nodes[nfNodes-1]);
//     }

//     // count up all filament nodes
//     int nNodes = nodeCount;

//     // now do same image thingy with motors/pinches... //
//     //nNodes += _motors.size()*2;
//     //nNodes += _pinches.size()*2;

//     //Mo
//     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
//       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
//       nNodes += crosslinknodes.size();
//     }

//     assert(nNodes == printNodes.size());
    
//     ofs << "# vtk DataFile Version 2.0\n"
// 	<< "Test example" << std::endl
// 	<< "ASCII" << std::endl
// 	<< "DATASET POLYDATA" << std::endl
// 	<< "POINTS  " << nNodes << "  double" << std::endl;
    

//     // output nodal postions
//     for(DefNodeIterator nid=printNodes.begin(); nid!=printNodes.end(); nid++ ) {
//       Vector2D & nodalPos = (*nid)->position();
//       // if the node is NOT an image node, map its position //
//       if(imageNodes.find(*nid) == imageNodes.end()) {
// 	_box->setShear(0.0);
// 	_box->mapPoint(nodalPos);       
//       }
//       ofs << std::setprecision(16) 
// 	  << nodalPos(0) << "  "
// 	  << 0.0 << "  "
// 	  << nodalPos(1) << std::endl;
//     }

// //     for (ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
// //       const Vector2D & nodalPos1 = (*m)->getStartPoint();
// //       const Vector2D & nodalPos2 = (*m)->getStartPoint();
// //       ofs << std::setprecision(16)
// // 	  << nodalPos1(0) << "  "
// // 	  << 0.0 << "  "
// //           << nodalPos1(1) <<std::endl;
// //       ofs << std::setprecision(16)
// // 	  << nodalPos2(0) << "  "
// // 	  << 0.0 << "  "
// //           << nodalPos2(1) <<std::endl;
// //     }

// //     //Mo
// //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
// //       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
// //       ConstDefNodeIterator pn = crosslinknodes.begin();
// //       for ( ; pn!= crosslinknodes.end(); pn ++) {
// //         const Vector2D & nodalPos = (*pn)->position();
// //         ofs << std::setprecision(16) 
// // 	    << nodalPos(0) << "  "
// // 	    << 0.0 << "  "
// // 	    << nodalPos(1) << std::endl;
// //       }
// //     }

//     //
//     // segment connectivity data
//     //

//     int nSegments = mainPairs.size() + imgPairs.size();

//     int nSegsMeas = 0;
//     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
//       nSegsMeas += (*f)->bonds.size();
//     }
//     assert(nSegsMeas == mainPairs.size());

// //     nSegments += _motors.size();

// //     //Mo
// //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
// //       nSegments++;
// //     }

//     ofs << "LINES  " << nSegments << "  "
// 	<< 3*nSegments << std::endl;
//     for( typename std::vector< pair<DefNode*,DefNode*> >::iterator np=mainPairs.begin(); np!=mainPairs.end(); np++ ) {
//       DefNode* n1 = np->first;
//       DefNode* n2 = np->second;
//       int indx1 = nodeIDMap[n1];
//       int indx2 = nodeIDMap[n2];

//       ofs << 2 << "  "
// 	  << std::setw(10) << indx1
// 	  << std::setw(10) << indx2
// 	  << std::endl;
     
//     }

//     for( typename std::vector< pair<DefNode*,DefNode*> >::iterator np=imgPairs.begin(); np!=imgPairs.end(); np++ ) {
//       DefNode* n1 = np->first;
//       DefNode* n2 = np->second;
//       int indx1 = nodeIDMap[n1];
//       int indx2 = nodeIDMap[n2];

//       ofs << 2 << "  "
// 	  << std::setw(10) << indx1
// 	  << std::setw(10) << indx2
// 	  << std::endl;
     
//     }
// //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
// //       ofs << 2 << "  "
// // 	  << std::setw(10) << nodeID
// // 	  << std::setw(10) << nodeID+1
// // 	  << std::endl;
// //       nodeID += 2;
// //     }
     	
// //     //Mo
// //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
// //       ofs << 2 << "  "
// // 	  << std::setw(10) << nodeID
// // 	  << std::setw(10) << nodeID+1
// // 	  << std::endl;
// //       nodeID+=2;
// //     }

//     //
//     //  output energy for each segment
//     //
// //     ofs << "CELL_DATA    " << nSegments << std::endl;

// //     ofs << "SCALARS    Energy    double    1" << std::endl;
// //     ofs << "LOOKUP_TABLE default" << std::endl;
// //     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
// //       int firstAngle=0;
// //       int lastAngle=(*f)->angles.size()-1;   //What happened to those two variables???  --Mo
// //       for(int a=0; a < (*f)->bonds.size(); a++) {
// // 	double energy = (*f)->bonds[a]->energy();
// // 	// 	energy += 0.5*(*f)->bonds[std::max(a-1,firstAngle)]->energy();
// // 	// 	energy += 0.5*(*f)->bonds[std::min(a,lastAngle)]->energy();
// // 	ofs << energy << std::endl;
// //       }
// //     }
// //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
// //       ofs << (*m)->energy() << std::endl;
// //     }
// //     ofs << std::endl;

// //     //Mo
// //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
// //       double energy = (*c)->energy();
// //       ofs << energy << std::endl;
// //     }
      
// //     ofs << std::endl;

//     ofs << "SCALARS    Energy    double    1" << std::endl;
//     ofs << "LOOKUP_TABLE default" << std::endl;
//     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
//       int nAngles = (*f)->angles.size();   //What happened to those two variables???  --Mo
//       for(int a=0; a < (*f)->bonds.size(); a++) {
// 	double energy = (*f)->bonds[a]->energy();
// 	if(a==0 && nAngles>0) energy += .5*(*f)->angles[0]->energy();
// 	else if(a==(*f)->bonds.size()-1 && nAngles>0) energy += .5*(*f)->angles[nAngles-1]->energy();
// 	else if(nAngles>0) {
// 	  energy += 0.5*(*f)->angles[a]->energy();
// 	  energy += 0.5*(*f)->angles[a-1]->energy();
// 	}
// 	ofs << energy << std::endl;
//       }
//     }

//     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;
 
// //     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
// //       ofs << (*m)->energy() << std::endl;
// //     }
// //     ofs << std::endl;

// //     //Mo
// //     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
// //       double energy = (*c)->energy();
// //       ofs << energy << std::endl;
// //     }
      
//     ofs << std::endl;

//     ofs << "SCALARS    BendEnergy    double    1" << std::endl;
//     ofs << "LOOKUP_TABLE default" << std::endl;
//     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
//       int nAngles = (*f)->angles.size();   //What happened to those two variables???  --Mo
//       for(int a=0; a < (*f)->bonds.size(); a++) {
// 	double energy = 0.0;
// 	if(a==0 && nAngles>0) energy += .5*((*f)->angles[0]->energy());
// 	else if(a==(*f)->bonds.size()-1 && nAngles>0) energy += 0.5*((*f)->angles[nAngles-1]->energy());
// 	else if(nAngles>0) {
// 	  energy += 0.5*((*f)->angles[a]->energy());
// 	  energy += 0.5*((*f)->angles[a-1]->energy());
// 	}
// 	ofs << energy << std::endl;
//       }
//     }

//     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

//     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
//       ofs << 0.0 << std::endl;
//     }
//     ofs << std::endl;

//     //Mo
//     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
//       double energy = (*c)->energy();
//       ofs << 0.0 << std::endl;
//     }
      
//     ofs << std::endl;

//     ofs << "SCALARS    StretchEnergy    double    1" << std::endl;
//     ofs << "LOOKUP_TABLE default" << std::endl;
//     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
//       for(int a=0; a < (*f)->bonds.size(); a++) {
// 	double energy = (*f)->bonds[a]->energy();
// 	ofs << energy << std::endl;
//       }
//     }
//     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

//     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
//       ofs << (*m)->energy() << std::endl;
//     }
//     ofs << std::endl;

//     //Mo
//     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
//       double energy = (*c)->energy();
//       ofs << energy << std::endl;
//     }
      
//     ofs << std::endl;

//     ofs << "SCALARS    Angle    double    1" << std::endl;
//     ofs << "LOOKUP_TABLE default" << std::endl;
//     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
//       for(int a=0; a < (*f)->bonds.size(); a++) {
// 	VectorND sep;
// 	sep = (*f)->nodes[a+1]->position() - (*f)->nodes[a]->position();
// 	double ang = atan2(sep[1],sep[0]);
// 	if(ang < -M_PI/2.0) ang += M_PI;
// 	else if(ang >= M_PI/2.0) ang -= M_PI;
// 	ofs << ang << std::endl;
//       }
//     }

//     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

//     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
//       ofs << 0.0 << std::endl;
//     }
//     ofs << std::endl;

//     //Mo
//     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
//       double energy = (*c)->energy();
//       ofs << 0.0 << std::endl;
//     }
      
//     ofs << std::endl;

//     ofs << "SCALARS    FilLen    double    1" << std::endl;
//     ofs << "LOOKUP_TABLE default" << std::endl;
//     for( ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++ ) {
//       VectorND e2e;
//       int nNodes = (*f)->nodes.size();
//       e2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
//       double fl = norm2(e2e);
//       for(int a=0; a < (*f)->bonds.size(); a++) {
// 	ofs << fl << std::endl;
//       }
//     }

//     for(int iip=0; iip<imgPairs.size(); iip++) ofs << -1.0 << std::endl;

//     for( ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++ ) {
//       ofs << 0.0 << std::endl;
//     }
//     ofs << std::endl;

//     //Mo
//     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
//       double energy = (*c)->energy();
//       ofs << 0.0 << std::endl;
//     }
      
//     ofs << std::endl;

//     ofs << std::endl << "POINT_DATA " << nNodes << std::endl
// 	<< "VECTORS displacements double" << std::endl;

//     // output nodal displacements
//     for(DefNodeIterator nid=printNodes.begin(); nid!=printNodes.end(); nid++ ) {
//       Vector2D & nodalPos = (*nid)->position();
//       Vector2D nodalDisp;
//       // if the node is NOT an image node, map its point //
//       if(imageNodes.find(*nid) == imageNodes.end()) {
// 	_box->setShear(0.0);
// 	_box->mapPoint(nodalPos);
// 	nodalDisp = (*nid)->point() - nodalPos;
// 	_box->setShear(shear);
// 	_box->mapDistance(nodalDisp);
// 	_box->setShear(0.0);
//       }
//       else nodalDisp = (*nid)->point() - (*nid)->position();
      
//       ofs << std::setprecision(16) 
// 	  << nodalDisp(0) << '\t' 
// 	  << 0.0 << '\t' 
// 	  << nodalDisp(1)  << std::endl;
      
//     }
//     for (ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
//       Vector2D nodalPos1; 
//       nodalPos1 = (*m)->getEndPoint1()-(*m)->getStartPoint();
//       Vector2D nodalPos2;
//       nodalPos2 = (*m)->getEndPoint2()-(*m)->getStartPoint();
//       ofs << std::setprecision(16)
// 	  << nodalPos1(0) << "  "
// 	  << 0.0 << "  "
//           << nodalPos1(1) <<std::endl;
//       ofs << std::setprecision(16)
// 	  << nodalPos2(0) << "  "
// 	  << 0.0 << "  "
//           << nodalPos2(1) <<std::endl;
//     }
    
//     //Mo
//     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
//       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
//       ConstDefNodeIterator pn = crosslinknodes.begin();
//       for ( ; pn!= crosslinknodes.end(); pn ++) {
//         Vector2D nodalDisp;
//         nodalDisp = (*pn)->point() - (*pn)->position();
//         ofs << std::setprecision(16) 
// 	    << nodalDisp(0) << '\t'
// 	    << 0.0 << '\t'
// 	    << nodalDisp(1) << std::endl;
// 	//cout << " semiflexible " << (*pn) <<' ' << (*pn)->point() <<endl;
//       }
      
//     }

//     ofs << std::endl << "VECTORS forces double" << std::endl;
//     // output nodal forces
//     for(DefNodeIterator nid=printNodes.begin(); nid!=printNodes.end(); nid++ ) {
// //       Vector2D & nodalPos = (*nid)->position();
// //       Vector2D nodalDisp;
// //       // if the node is NOT an image node, map its point //
// //       if(imageNodes.find(*nid) == imageNodes.end()) {
// // 	_box->setShear(0.0);
// // 	_box->mapPoint(nodalPos);
// // 	nodalDisp = (*nid)->point() - nodalPos;
// // 	_box->setShear(shear);
// // 	_box->mapDistance(nodalDisp);
// // 	_box->setShear(0.0);
// //       }
// //       else nodalDisp = (*nid)->point() - (*nid)->position();

//       const Vector2D & nodalForce = (*nid)->force();
      
//       ofs << std::setprecision(16) 
// 	  << nodalForce(0) << '\t' 
// 	  << 0.0 << '\t' 
// 	  << nodalForce(1)  << std::endl;
      
//     }

//     for (ConstMotorIterator m=_motors.begin(); m!=_motors.end(); m++) {
//       ofs << std::setprecision(16)
// 	  << 0.0 << '\t'
// 	  << 0.0 << '\t'
// 	  << 0.0 << std::endl;
//       ofs << std::setprecision(16)
// 	  << 0.0 << '\t'
// 	  << 0.0 << '\t'
// 	  << 0.0 << std::endl;
//     }


//     //Mo
//     for( ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++ ) {
//       const DefNodeContainer & crosslinknodes = (*c)-> getNodes();
//       ConstDefNodeIterator pn = crosslinknodes.begin();
//       for ( ; pn!= crosslinknodes.end(); pn ++) {
//         const Vector2D & nodalForce = (*pn)->force();
//         ofs << std::setprecision(16) 
// 	    << nodalForce(0) << '\t'
// 	    << 0.0 << '\t'
// 	    << nodalForce(1) << std::endl;
//       }
//     }
    
//     ofs.close();

//     printNodes.clear();
//     imageNodes.clear();
//     mainPairs.clear();
//     imgPairs.clear();
//     nodeIDMap.clear();

    return;

  }
  
  template<int N>
  void SemiflexibleGel<N>::storeGel(std::string fileName) {
    int intSize = sizeof(int);
    int doubleSize = sizeof(double);

    std::ofstream outFile(fileName.data(), ios::out | ios::binary);
    VectorND sysSize(_box->size());
    for(int i=0; i<N; i++) {
      double curSS = sysSize[i];
      outFile.write((char *)(&curSS),doubleSize);
    }
    int nFils = _filaments.size();
    outFile.write((char *)(&nFils),intSize);
    
    std::vector<intPair> slaveCLs(_constraints.size());
    std::vector<intPair> tmpMastCLs(_constraints.size());
    std::vector<intPair> mastCLs(_constraints.size());
    std::multimap<DefNode*, int> slaveInds;
    int sn = 0;
    int mn = 0;
    
    for(int j=0; j<nFils; j++) {
      Filament * f = filament(j);
      int nNodesHere = f->nodes.size();
      outFile.write((char *)(&nNodesHere),intSize);
      for(int k=0; k<nNodesHere; k++) {
	DefNode * curNode = f->nodes[k];
	VectorND curPos(curNode->point());
	VectorND refPos(curNode->position());
	for(int kdof=0; kdof<N; kdof++) {
	  double cpdof = curPos[kdof];
	  outFile.write((char *)(&cpdof),doubleSize);
	}
	for(int kdof=0; kdof<N; kdof++) {
	  double rpdof = refPos[kdof];
	  outFile.write((char *)(&rpdof),doubleSize);
	}
	
	CLNMiter cnmi = _crossNodeMap.find(curNode);
	if(cnmi != _crossNodeMap.end()) {
	  DefNode * mast = cnmi->second;
	  
	  if(mast != curNode) {
	    slaveInds.insert(pair< DefNode*, int >(mast,sn));
	    slaveCLs[sn] = pair< int, int >(j,k);
	    sn++;
	  }
	  
	  else if(mast == curNode) {
	    tmpMastCLs[mn] = pair< int, int >(j,k);
	    mn++;
	  }
	}
      }
    }

    // write the number of crosslinks to the file //
    int nCL = _constraints.size();
    outFile.write((char *)(&nCL),intSize);
    
    // now go back and put master nodes in the right order //
    std::vector<intPair>::iterator pairIter;
    for(pairIter=tmpMastCLs.begin(); pairIter!=tmpMastCLs.end(); pairIter++) {
      DefNode * curMast = filament(pairIter->first)->nodes[pairIter->second];
      std::pair<SNiter, SNiter> sniter; 
      // SNiter sniter;
      sniter = slaveInds.equal_range(curMast);
      // assert(sniter != slaveInds.end());
      SNiter sni;
      for(sni=sniter.first; sni!=sniter.second; sni++) {
        int slaveInd = sni->second;
	mastCLs[slaveInd] = *pairIter;
      }
      // int slaveInd = sniter->second; 
      // mastCLs[slaveInd] = *pairIter;
    }
    
    std::cout << "Gel storage consistency check: # of constraints in gel = " << nCL << ", # of slave nodes = " << slaveCLs.size() << ", # of master nodes = " << mastCLs.size() << "." << std::endl;
    
    for(int cl=0; cl<nCL; cl++) {
      outFile.write((char *)(&(slaveCLs[cl].first)),intSize);
      outFile.write((char *)(&(slaveCLs[cl].second)),intSize);
      outFile.write((char *)(&(mastCLs[cl].first)),intSize);
      outFile.write((char *)(&(mastCLs[cl].second)),intSize);
    }
    
    std::cout << "Finished storing gel to file " << fileName << "; current file pointer position is " << outFile.tellp() << "." << std::endl;

    outFile.close();
  }

  template<int N>
  void SemiflexibleGel<N>::storeSparseGel(std::string fileName, TempFilamentContainer & tmpFils) {
    int intSize = sizeof(int);
    int doubleSize = sizeof(double);

    std::ofstream outFile(fileName.data(), ios::out | ios::binary);
    VectorND sysSize(_box->size());
    for(int i=0; i<N; i++) {
      double curSS = sysSize[i];
      outFile.write((char *)(&curSS),doubleSize);
    }
    int nFils = tmpFils.size();
    outFile.write((char *)(&nFils),intSize);
    
    int totalCrosslinks = 0;
    for(int j=0; j<nFils; j++) {
      for(int i=0; i<N; i++) {
	double posi = tmpFils[j]->start[i];
	outFile.write((char *)(&posi),doubleSize);
      }
      for(int i=0; i<N; i++) {
	double posi = tmpFils[j]->end[i];
	outFile.write((char *)(&posi),doubleSize);
      }
      typename multimap<double,TempCrosslink*>::iterator cls = tmpFils[j]->crossFils.begin();
      for(cls; cls!=tmpFils[j]->crossFils.end(); cls++) {
        if(cls->second->active && cls->second->baseFil == j) totalCrosslinks++;
      }
    }
	
    //assert(totalCrosslinks%2 == 0);
    //totalCrosslinks /= 2;
	
    outFile.write((char *)(&totalCrosslinks),intSize);
    int writtenCrosslinks = 0;
    for(int j=0; j<nFils; j++) {
      typename multimap<double,TempCrosslink*>::iterator cls = tmpFils[j]->crossFils.begin();
      for(cls; cls!=tmpFils[j]->crossFils.end(); cls++) {
	if(cls->second->active && cls->second->baseFil == j) {
          int nCLFils = cls->second->otherFils.size();
	  outFile.write((char *)(&nCLFils),intSize);
	  typename map< int, VectorND >::iterator ofs = cls->second->otherFils.begin();
	  for(ofs; ofs!=cls->second->otherFils.end(); ofs++) {
	    int filind = ofs->first;
            outFile.write((char *)(&filind),intSize);
	    VectorND cllocalpos;
	    cllocalpos = ofs->second;
	    for(int i=0; i<N; i++) {
	      double clposi = cllocalpos[i];
	      outFile.write((char *)(&clposi),doubleSize);
	    }
          }
	  //VectorND clpos = cls->second->location;
	  //for(int i=0; i<N; i++) {
	  //double clposi = clpos[i];
	  //outFile.write((char *)(&clposi),doubleSize);
	  //}
	  writtenCrosslinks++;
	}
      }
    }

    assert(writtenCrosslinks == totalCrosslinks);
    
    std::cout << "Finished storing gel to file " << fileName << " with " << nFils << " filaments and " << writtenCrosslinks << " crosslinks; current file pointer position is " << outFile.tellp() << "." << std::endl;

    outFile.close();
  }

  template<int N>
  void SemiflexibleGel<N>::attachMotor(MolMot * mot, const Filament * f1, const Filament * f2) {
    int nNodesFil1 = f1->nodes.size();
    int nNodesFil2 = f2->nodes.size();
    DefNodeIterator node1Iter = f1->nodes.begin();
    DefNodeIterator node2Iter = f2->nodes.begin();
    DefNode * node1A = *node1Iter;
    DefNode * node2A = *node2Iter;
    DefNode * node1B = *(f1->nodes.end()-1);
    DefNode * node2B = *(f2->nodes.end()-1);
    VectorND x1A = node1A->point();
    VectorND x1B = node1B->point();
    VectorND x2A = node2A->point();
    VectorND x2B = node2B->point();
    VectorND xintersect1;
    VectorND xintersect2;
    double end_to_end1 = norm2(x1B-x1A);
    double end_to_end2 = norm2(x2B-x1A);
    double tol = (end_to_end1+end_to_end2)/2.0;

    double a1,a2;
    if(abs(x1B[0]-x1A[0]) > 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6) {
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[0] = (x1A[1]-x2A[1]+a2*x2A[0]-a1*x1A[0])/(a2-a1);
      xintersect1[1] = (a2*(x1A[1]-a1*x1A[0])-a1*(x2A[1]-a2*x2A[0]))/(a2-a1);
    }
    else if(abs(x1B[0]-x1A[0]) <= 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6){
      xintersect1[0] = x1A[0];
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[1] = a2*x1A[0] + x2A[1] - a2*x2A[0];
    }
    else if(abs(x2B[0]-x2A[0]) <= 1.0e-6 && abs(x1B[0]-x1A[0]) > 1.0e-6) {
      xintersect1[0] = x2A[0];
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      xintersect1[1] = x1A[1] - a1*(x1A[0] - x2A[0]);
    }
    else {
      xintersect1[0] = (x1A[0]+x2A[0])/2.0;
      xintersect1[1] = 1.0e30;
    }

    int node_jump1 = min((int)(nNodesFil1*norm2(xintersect1-x1A)/end_to_end1),nNodesFil1-2);
    int node_jump2 = min((int)(nNodesFil2*norm2(xintersect1-x2A)/end_to_end2),nNodesFil2-2);

    if(dot(x1B-x1A,xintersect1-x1A)<0.0) {
      node_jump1 = 0;
    }

    if(dot(x2B-x2A,xintersect1-x2A)<0.0) {
      node_jump2 = 0;
    }
      
    bool intersected = false;
    int rad = 1;
    int curRadCounter = 0;
    int totCounter = 0;
    int node1_offset = node_jump1;
    int node2_offset = node_jump2;
      
    while(intersected == false && totCounter < (nNodesFil1-1)*(nNodesFil2-1)) {
      if(node1_offset >= 0 && node2_offset >= 0 && node1_offset < nNodesFil1 - 1 && node2_offset < nNodesFil2 - 1 && (abs(node1_offset-node_jump1) >= (rad-1)/2 || abs(node2_offset-node_jump2) >= (rad-1)/2)) {
	node1A = *(node1Iter + node1_offset);
	node1B = *(node1Iter + node1_offset + 1);
	node2A = *(node2Iter + node2_offset);
	node2B = *(node2Iter + node2_offset + 1);
	x1A = node1A->point();
	x1B = node1B->point();
	x2A = node2A->point();
	x2B = node2B->point();
	intersected = IntersectionFinder<N>::checkIntersection(x1A,x1B,x2A,x2B,xintersect1,xintersect2,tol,_box);
	if(intersected == true) {
	  mot->setPosition(f1->nodes,node1_offset,f2->nodes,node2_offset,xintersect1,xintersect2);
	  _motors.push_back(mot);
	}
	totCounter++;
      }
      curRadCounter++;
      if(curRadCounter >= sqr(rad)) {
	rad += 2;
	curRadCounter = 0;
      }
	
      node2_offset = node_jump2 - ((rad-1)/2) + curRadCounter%rad;
      node1_offset = node_jump1 - ((rad-1)/2) + curRadCounter/rad;
    }
  }

  template<int N>
  void SemiflexibleGel<N>::addPinch(DefNode* node1, DefNode* node2, double f0) {
    Pinch * newPinch = new PinchForce<N>(node1,node2,f0,_box);
    _pinches.push_back(newPinch);
    _pinchNodes.insert(node1);
    _pinchNodes.insert(node2);
  }
  
  template<int N>
  void SemiflexibleGel<N>::addPinch(double a, double tol, double f0) {
    
  }

  template<int N>
  void SemiflexibleGel<N>::addPinches(int nPinches, double a, double tol, double f0) {
    // set up grid and get neighbors //
    VectorND pinchSep;
    for(int i=0; i<N; i++) pinchSep[i] = a;
    NodeGrid* ngrid = new Grid<DefNode,BaseDefNode,N>(_box,pinchSep,&DeformationNode<N>::position,true);
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      if((*fi)->nodes.size() > 1) {
	ngrid->addElems((*fi)->nodes);
      }
    }
    
    int nAdded = 0;
    std::map< DefNode*,std::set<DefNode*> > & nodeNeighbs = ngrid->getNeighbors();
    for(typename map< DefNode*,set<DefNode*> >::iterator neighbit=nodeNeighbs.begin(); neighbit!=nodeNeighbs.end(); neighbit++) {
      DefNode* n1 = neighbit->first;
      for(typename set<DefNode*>::iterator secit=neighbit->second.begin(); secit!=neighbit->second.end(); secit++) {
	DefNode* n2 = *secit;
	if(n1>n2) {
	  VectorND pos1;
	  pos1= n1->position();
	  VectorND pos2;
	  pos2 = n2->position();
	  VectorND sep;
	  sep = pos2 - pos1;
	  _box->mapDistance(sep);
	  double dist = norm2(sep);
	  if(nAdded<nPinches && fabs(dist-a)<tol && _pinchNodes.find(n1) == _pinchNodes.end() && _pinchNodes.find(n2) == _pinchNodes.end()) {
	    addPinch(n1,n2,f0);
	    nAdded++;
	  }
	}
      }
    }
    if(nAdded != nPinches) std::cout << "Only added " << nAdded << " motors, not " << nPinches << " as requested." << std::endl;
    ngrid->clearGrid();
    delete ngrid;
  }

  template<int N>
  void SemiflexibleGel<N>::addPinches(double pinchDensity, double a, double tol, double f0) {
    double vol = 1.0;
    for(int i=0; i<N; i++) vol *= _box->size()[i];
    int nPinches = (int)(pinchDensity*vol);
    addPinches(nPinches,a,tol,f0);
  }

  
  //   template<int N>
  //   void SemiflexibleGel<N>::addPinch(DefNode * n1, DefNode * n2, double f0, bool springy) {
  //     Pinch * newPinch = new PinchForce<N>(n1,n2,f0,_box,springy);
  //     _pinches.push_back(newPinch);
  //   }
  
  //   template<int N>
  //   void SemiflexibleGel<N>::addPinch(double a, double f0, bool springy) {
  //     const VectorND & sysSize = _box->size();
  //     double tol = sysSize(0)/10.0;
  //     CLNMiter cni = _crossNodeMap.begin();
  //     bool foundFirst = false;
  //     bool foundPair = false;
  //     DefNode * firstNode;
  //     while(foundPair==false && cni!=_crossNodeMap.end()) {
  //       DefNode * curMaster = cni->second;
  //       if(foundFirst==false && norm2(curMaster->point()-(sysSize/2.0)) <= tol) {
  // 	foundFirst = true;
  // 	firstNode = curMaster;
  // 	std::cout << "Found first pinch site: " << firstNode->point()[0] << ", " << firstNode->point()[1] << std::endl;
  //       }
  //       else if(foundFirst==true && curMaster!=firstNode && fabs(norm2(firstNode->point()-curMaster->point())-a) < 5.0e-1) {
  // 	addPinch(firstNode,curMaster,f0,springy);
  // 	foundPair = true;
  // 	std::cout << "Found second pinch site: " << curMaster->point()[0] << ", " << curMaster->point()[1] << std::endl;
  //       }
  //       cni++;
  //     }
    
  //   }

  //   template<int N>
  //   void SemiflexibleGel<N>::addPinch(double f0, bool springy, DefNodeContainer & dNodes, double kBond, double kAngle, double visc, double kT, double dt, double kcl) {
  //     const VectorND & sysSize = _box->size();
  //     double rodLen = norm2(filament(0)->nodes[0]->point() - filament(0)->nodes[1]->point());
  //     int nNodesPF = filament(0)->nodes.size();
  //     int nFils = _filaments.size();
  //     int id;
  //     double ang = _rnguni->random()*2.0*3.14159;
  //     NodeBase::DofIndexMap idx(N);
  //     DefNode * newDN;
  //     VectorND startPos;
  //     VectorND curPos;
  //     startPos = sysSize/2.0;
  //     VectorND rodVec;
  //     DefNodeContainer tmpDNC(nNodesPF);
  //     DefNodeContainer tmpDNC2(nNodesPF);
  //     for(int i=0; i<nNodesPF; i++) {
  //       id = nFils*nNodesPF + i;
  //       for(int k=0; k<N; k++) {
  // 	idx[k] = N*id + k;
  //       }
  //       curPos[0] = startPos[0] + i*cos(ang)*rodLen;
  //       curPos[1] = startPos[1] + i*sin(ang)*rodLen;
  //       newDN = new BrownianNode<N>(id,idx,curPos,curPos);
  //       newDN->setId(id);
  //       tmpDNC[i] = newDN;
  //       dNodes.push_back(newDN);
  //       id += nNodesPF;
  //       for(int k=0; k<N; k++) {
  // 	idx[k] = N*id + k;
  //       }
  //       curPos[0] -= rodLen*6*sin(ang);
  //       curPos[1] += rodLen*6*cos(ang);
  //       newDN = new BrownianNode<N>(id,idx,curPos,curPos);
  //       newDN->setId(id);
  //       tmpDNC2[i] = newDN;
  //       dNodes.push_back(newDN);
  //     }
  //     FilamentContainer tmpFC;
  //     addFilament(tmpDNC,kBond,kAngle,visc,kT,dt);
  //     addFilament(tmpDNC2,kBond,kAngle,visc,kT,dt);
  //     Filament * f1 = filament(nFils);
  //     Filament * f2 = filament(nFils+1);
  //     for(int l=0; l<nFils; l++) {
  //       Filament * fold = filament(l);
  //       VectorND sep;
  //       bool twoAtt = false;
  //       sep = ((fold->nodes)[0])->point() - ((f1->nodes)[0])->point();
  //       _box->mapDistance(sep);
  //       if(norm2(sep) <= 2.0*rodLen*(nNodesPF-1)) {
  // 	bool att = false;
  // 	att = attachCrosslink(f1,fold,kcl);
  // 	if(att) twoAtt = true;
  //       }
      
  //       sep = ((fold->nodes)[0])->point() - ((f2->nodes)[0])->point();
  //       _box->mapDistance(sep);
  //       if(norm2(sep) <= 2.0*rodLen*(nNodesPF-1)) {
  // 	bool att = false;
  // 	att = attachCrosslink(f2,fold,kcl);
  // 	if(att==false && twoAtt==true) twoAtt = false;
  //       }
  //       else twoAtt = false;

  //       if(twoAtt) tmpFC.push_back(fold);
  //     }

  //     bool foundclinkpts = false;
  //     int i = 3;
  //     int d1,d2;
  //     while(!foundclinkpts && i < nNodesPF-3) {
  //       i++;
  //       d1 = 0;
  //       d2 = 0;
  //       if(_crossNodeMap.find(f1->nodes[i]) == _crossNodeMap.end() && _crossNodeMap.find(f2->nodes[i]) == _crossNodeMap.end()) {
  // 	d1 = 1;
  // 	while(i-d1>0 && _crossNodeMap.find(f1->nodes[i-d1]) == _crossNodeMap.end()) {
  // 	  d1++;
  // 	}
  // 	if(d1>1 && i-d1>0) {
  // 	  d2 = 1;
  // 	  while(i+d2<nNodesPF-1 && _crossNodeMap.find(f2->nodes[i+d2]) == _crossNodeMap.end()) {
  // 	    d2++;
  // 	  }
  // 	  if(d2>1 && i+d2<nNodesPF-1) {
  // 	    DefNode * mast1 = (_crossNodeMap.find(f1->nodes[i-d1]))->second;
  // 	    DefNode * mast2 = (_crossNodeMap.find(f2->nodes[i+d2]))->second;
  // 	    addPinch(mast1,mast2,f0,springy);
  // 	    foundclinkpts = true;
  // 	    std::cout << "Added pinches at " << mast1->point()[0] << ", " << mast1->point()[1] << " and " << mast2->point()[0] << ", " << mast2->point()[1] << std::endl;
  // 	  }	
  // 	}
  //       }
  //     }
  //   }

  template<int N>
  void SemiflexibleGel<N>::attachCrosslink(Clink * cl, const Filament * f1, const Filament * f2) {
    int nNodesFil1 = f1->nodes.size();
    int nNodesFil2 = f2->nodes.size();
    DefNodeIterator node1Iter = f1->nodes.begin();
    DefNodeIterator node2Iter = f2->nodes.begin();
    DefNode * node1A = *node1Iter;
    DefNode * node2A = *node2Iter;
    DefNode * node1B = *(f1->nodes.end()-1);
    DefNode * node2B = *(f2->nodes.end()-1);
    VectorND x1A = node1A->point();
    VectorND x1B = node1B->point();
    VectorND x2A = node2A->point();
    VectorND x2B = node2B->point();
    VectorND xintersect1;
    VectorND xintersect2;
    double end_to_end1 = norm2(x1B-x1A);
    double end_to_end2 = norm2(x2B-x1A);
    double tol = (end_to_end1+end_to_end2)/2.0;

    double a1,a2;
    if(abs(x1B[0]-x1A[0]) > 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6) {
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[0] = (x1A[1]-x2A[1]+a2*x2A[0]-a1*x1A[0])/(a2-a1);
      xintersect1[1] = (a2*(x1A[1]-a1*x1A[0])-a1*(x2A[1]-a2*x2A[0]))/(a2-a1);
    }
    else if(abs(x1B[0]-x1A[0]) <= 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6){
      xintersect1[0] = x1A[0];
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[1] = a2*x1A[0] + x2A[1] - a2*x2A[0];
    }
    else if(abs(x2B[0]-x2A[0]) <= 1.0e-6 && abs(x1B[0]-x1A[0]) > 1.0e-6) {
      xintersect1[0] = x2A[0];
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      xintersect1[1] = x1A[1] - a1*(x1A[0] - x2A[0]);
    }
    else {
      xintersect1[0] = (x1A[0]+x2A[0])/2.0;
      xintersect1[1] = 1.0e30;
    }

    int node_jump1 = min((int)(nNodesFil1*norm2(xintersect1-x1A)/end_to_end1),nNodesFil1-2);
    int node_jump2 = min((int)(nNodesFil2*norm2(xintersect1-x2A)/end_to_end2),nNodesFil2-2);

    if(dot(x1B-x1A,xintersect1-x1A)<0.0) {
      node_jump1 = 0;
    }

    if(dot(x2B-x2A,xintersect1-x2A)<0.0) {
      node_jump2 = 0;
    }
      
    bool intersected = false;
    int rad = 1;
    int curRadCounter = 0;
    int totCounter = 0;
    int node1_offset = node_jump1;
    int node2_offset = node_jump2;
      
    while(intersected == false && totCounter < (nNodesFil1-1)*(nNodesFil2-1)) {
      if(node1_offset >= 0 && node2_offset >= 0 && node1_offset < nNodesFil1 - 1 && node2_offset < nNodesFil2 - 1 && (abs(node1_offset-node_jump1) >= (rad-1)/2 || abs(node2_offset-node_jump2) >= (rad-1)/2)) {
	node1A = *(node1Iter + node1_offset);
	node1B = *(node1Iter + node1_offset + 1);
	node2A = *(node2Iter + node2_offset);
	node2B = *(node2Iter + node2_offset + 1);
	x1A = node1A->point();
	x1B = node1B->point();
	x2A = node2A->point();
	x2B = node2B->point();
	intersected = IntersectionFinder<N>::checkIntersection(x1A,x1B,x2A,x2B,xintersect1,xintersect2,tol,_box);
	if(intersected == true) {
	  double eps1 = norm2(xintersect1-x1A)/end_to_end1;
	  double eps2 = norm2(xintersect2-x2A)/end_to_end2;
	  cl->setPosition(node1A,node1B,node2A,node2B,eps1,eps2);
	  addCrosslink(cl);
	}
	totCounter++;
      }
      curRadCounter++;
      if(curRadCounter >= sqr(rad)) {
	rad += 2;
	curRadCounter = 0;
      }
	
      node2_offset = node_jump2 - ((rad-1)/2) + curRadCounter%rad;
      node1_offset = node_jump1 - ((rad-1)/2) + curRadCounter/rad;
    }
  }

  template<int N>
  bool SemiflexibleGel<N>::attachCrosslink(Filament * f1, Filament * f2, double kcl, double relax) {
    bool doRelax = false;
    if(relax > 0.0) {
      doRelax = true;
    }
    bool attachedCL = false;
    int nNodesFil1 = f1->nodes.size();
    int nNodesFil2 = f2->nodes.size();
    DefNodeContainer & f1nodes = f1->nodes;
    DefNodeContainer & f2nodes = f2->nodes;
    DefNode * node1A = f1nodes[0];
    DefNode * node2A = f2nodes[0];
    DefNode * node1B = f1nodes[nNodesFil1-1];
    DefNode * node2B = f2nodes[nNodesFil2-1];
    VectorND x1A = node1A->point();
    VectorND x1B = node1B->point();
    VectorND x2A = node2A->point();
    VectorND x2B = node2B->point();
    VectorND xintersect1;
    VectorND xintersect2;
    double end_to_end1 = norm2(x1B-x1A);
    double end_to_end2 = norm2(x2B-x2A);
    double tol = (end_to_end1+end_to_end2)/2.0;

    double a1,a2;
    if(abs(x1B[0]-x1A[0]) > 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6) {
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[0] = (x1A[1]-x2A[1]+a2*x2A[0]-a1*x1A[0])/(a2-a1);
      xintersect1[1] = (a2*(x1A[1]-a1*x1A[0])-a1*(x2A[1]-a2*x2A[0]))/(a2-a1);
    }
    else if(abs(x1B[0]-x1A[0]) <= 1.0e-6 && abs(x2B[0]-x2A[0]) > 1.0e-6){
      xintersect1[0] = x1A[0];
      a2 = (x2B[1]-x2A[1])/(x2B[0]-x2A[0]);
      xintersect1[1] = a2*x1A[0] + x2A[1] - a2*x2A[0];
    }
    else if(abs(x2B[0]-x2A[0]) <= 1.0e-6 && abs(x1B[0]-x1A[0]) > 1.0e-6) {
      xintersect1[0] = x2A[0];
      a1 = (x1B[1]-x1A[1])/(x1B[0]-x1A[0]);
      xintersect1[1] = x1A[1] - a1*(x1A[0] - x2A[0]);
    }
    else {
      xintersect1[0] = (x1A[0]+x2A[0])/2.0;
      xintersect1[1] = 1.0e30;
    }

    int node_jump1 = min((int)(nNodesFil1*norm2(xintersect1-x1A)/end_to_end1),nNodesFil1-2);
    int node_jump2 = min((int)(nNodesFil2*norm2(xintersect1-x2A)/end_to_end2),nNodesFil2-2);

    if(dot(x1B-x1A,xintersect1-x1A)<0.0) {
      node_jump1 = 0;
    }

    if(dot(x2B-x2A,xintersect1-x2A)<0.0) {
      node_jump2 = 0;
    }
    
    bool intersected = false;
    int ctr1 = 0;
    int node1_offset = node_jump1;
    
    while(intersected == false && ctr1 < (nNodesFil1-1)) {
      int ctr2 = 0;
      int node2_offset = node_jump2;
      while(intersected == false && ctr2 < (nNodesFil2-1)) {
	node1A = f1nodes[node1_offset];
	node1B = f1nodes[node1_offset+1];
	node2A = f2nodes[node2_offset];
	node2B = f2nodes[node2_offset+1];
	x1A = node1A->point();
	x1B = node1B->point();
	x2A = node2A->point();
	x2B = node2B->point();
	end_to_end1 = norm2(x1B-x1A);
	end_to_end2 = norm2(x2B-x2A);
	tol = (end_to_end1+end_to_end2)/2.0;
	intersected = IntersectionFinder<N>::checkIntersection(x1A,x1B,x2A,x2B,xintersect1,xintersect2,tol,_box);
	if(intersected == true) {
	  double eps1 = norm2(xintersect1-x1A)/end_to_end1;
	  double eps2 = norm2(xintersect2-x2A)/end_to_end2;
	  if(kcl >= 0.0) { // if the crosslink spring constant is non-negative, add real crosslink //
	    attachedCL = true;
	    Clink * cl = new Crosslink<N>(node1A,node1B,node2A,node2B,eps1,eps2,kcl,_box,doRelax);
	    addCrosslink(cl);
	    
	    int clposlow = 0;
	    int clposhigh = f1->clinks.size();
	    while(clposhigh - clposlow > 1) {
	      int clposcur = (clposhigh + clposlow)/2;
	      if(node1_offset + eps1 >= f1->clinks[clposcur]) clposlow = clposcur;
	      else clposhigh = clposcur;
	    }
	    if(clposhigh == 0) f1->clinks.push_back(node1_offset+eps1);
	    else if(f1->clinks.size() == 1) {
	      if(node1_offset + eps1 < f1->clinks[0]) {
		std::vector< double >::iterator clq = f1->clinks.begin();
		f1->clinks.insert(clq,node1_offset+eps1);
	      }
	      else f1->clinks.push_back(node1_offset+eps1);
	    }
	    else if(clposlow == 0) {
	      if(node1_offset + eps1 < f1->clinks[0]) {
		std::vector< double >::iterator clq = f1->clinks.begin();
		f1->clinks.insert(clq,node1_offset+eps1);
	      }
	      else {
		std::vector< double >::iterator clq = f1->clinks.begin();
		f1->clinks.insert(clq+1,node1_offset+eps1);
	      }
	    }
	    else if(clposhigh == f1->clinks.size()) {
	      if(node1_offset + eps1 >= f1->clinks[clposhigh-1]) f1->clinks.push_back(node1_offset+eps1);
	      else {
		std::vector< double >::iterator clq = f1->clinks.end();
		f1->clinks.insert(clq-1,node1_offset+eps1);
	      }
	    }
	    else {
	      std::vector< double >::iterator clq = f1->clinks.begin();
	      f1->clinks.insert(clq+clposhigh,node1_offset+eps1);
	    }

	    clposlow = 0;
	    clposhigh = f2->clinks.size();
	    while(clposhigh - clposlow > 1) {
	      int clposcur = (clposhigh + clposlow)/2;
	      if(node2_offset + eps2 >= f2->clinks[clposcur]) clposlow = clposcur;
	      else clposhigh = clposcur;
	    }
	    if(clposhigh == 0) f2->clinks.push_back(node2_offset+eps2);
	    else if(f2->clinks.size() == 1) {
	      if(node2_offset + eps2 < f2->clinks[0]) {
		std::vector< double >::iterator clq = f2->clinks.begin();
		f2->clinks.insert(clq,node2_offset+eps2);
	      }
	      else f2->clinks.push_back(node2_offset+eps2);
	    }
	    else if(clposlow == 0) {
	      if(node2_offset + eps2 < f2->clinks[0]) {
		std::vector< double >::iterator clq = f2->clinks.begin();
		f2->clinks.insert(clq,node2_offset+eps2);
	      }
	      else {
		std::vector< double >::iterator clq = f2->clinks.begin();
		f2->clinks.insert(clq+1,node2_offset+eps2);
	      }
	    }
	    else if(clposhigh == f2->clinks.size()) {
	      if(node2_offset + eps2 >= f2->clinks[clposhigh-1]) f2->clinks.push_back(node2_offset+eps2);
	      else {
		std::vector< double >::iterator clq = f2->clinks.end();
		f2->clinks.insert(clq-1,node2_offset+eps2);
	      }
	    }
	    else {
	      std::vector< double >::iterator clq = f2->clinks.begin();
	      f2->clinks.insert(clq+clposhigh,node2_offset+eps2);
	    }
	  }
	  else { // a negative crosslink spring constant means we glue nodes together //
	    VectorND AA,BB,AB,BA;
	    AA = x1A - x2A;
	    BB = x1B - x2B;
	    AB = x1A - x2B;
	    BA = x1B - x2A;
	    _box->mapDistance(AA);
	    _box->mapDistance(BB);
	    _box->mapDistance(AB);
	    _box->mapDistance(BA);
	    double AAlen,BBlen,ABlen,BAlen;
	    AAlen = norm2(AA);
	    BBlen = norm2(BB);
	    ABlen = norm2(AB);
	    BAlen = norm2(BA);
	    // create a map to put distance/node pair pairs in so that they are sorted //
	    std::multimap < double, pair<DefNode*,DefNode*> > CLpairs;
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(AAlen,pair<DefNode*,DefNode*>(node1A,node2A)));
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(ABlen,pair<DefNode*,DefNode*>(node1A,node2B)));
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(BAlen,pair<DefNode*,DefNode*>(node1B,node2A)));
	    CLpairs.insert(pair<double,pair<DefNode*,DefNode*> >(BBlen,pair<DefNode*,DefNode*>(node1B,node2B)));
	    typename multimap< double,pair<DefNode*,DefNode*> >::iterator mi = CLpairs.begin();
	    while(!attachedCL && mi!=CLpairs.end()) {
	      //std::vector< pair<DefNode*,DefNode*> > pinPairs;
	      //if(_crossNodeMap.find((mi->second).first) == _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) != _crossNodeMap.end()) {
 	      //  pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).first,_crossNodeMap[(mi->second).second])); 
	      //}
	      //else if(_crossNodeMap.find((mi->second).first) != _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) == _crossNodeMap.end()) {
              //  pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).second,_crossNodeMap[(mi->second).first]));
	      //}
	      //else if(_crossNodeMap.find((mi->second).first) == _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) == _crossNodeMap.end()) {
              //  pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).second,(mi->second).first));
	      //pinPairs.push_back(pair<DefNode*,DefNode*>((mi->second).first,(mi->second).first));
	      //}	

  	      //if(relax>0.0 && pinPairs.size()!=0) {
	      // check to make sure induced bending isn't too much; if it is, clear out pinPairs //
	      //VectorND smdiff;
	      //smdiff = (pinPairs[0].second)->point() - (pinPairs[0].first)->point();
	      //_box->mapDistance(smdiff);
	      //smdiff += (pinPairs[0].first)->point();
	      //(pinPairs[0].first)->setPoint(smdiff);
	      //double energycost = 0.0;
	      //for(AngleIterator ai=f1->angles.begin(); ai!=f1->angles.end(); ai++) {
	      //  (*ai)->compute(true,false,false);
	      //  energycost += (*ai)->energy();
	      //}
	      //for(BondIterator bi=f1->bonds.begin(); bi!=f1->bonds.end(); bi++) {
	      //  (*bi)->compute(true,false,false);
	      //  energycost += (*bi)->energy();
	      //}
	      //for(AngleIterator ai=f2->angles.begin(); ai!=f2->angles.end(); ai++) {
	      //  (*ai)->compute(true,false,false);
	      //  energycost += (*ai)->energy();
	      //}
	      //for(BondIterator bi=f2->bonds.begin(); bi!=f2->bonds.end(); bi++) {
	      //  (*bi)->compute(true,false,false);
	      //  energycost += (*bi)->energy();
	      //}
	      //
	      //(pinPairs[0].first)->setPoint((pinPairs[0].first)->position());
		
	      //	if(energycost > relax) {
	      //	  pinPairs.clear();
	      //	  std::cout << "Crosslink would force excessive bending prestress (" << energycost << " > " << relax << "); deleting." << std::endl;
	      //	}
	      //    }
	      
	      //if(pinPairs.size()!=0) {
	      //  PeriodicTie<N> * pt = new PeriodicTie<N>(pinPairs[0].second,pinPairs[0].first,_box,true);
	      //addConstraint(pt);
	      //for(int pct=0; pct<pinPairs.size(); pct++) {
	      //  _crossNodeMap.insert(pinPairs[pct]);
	      //}
	      //attachedCL = true;
	      //}
	
	      if(_crossNodeMap.find((mi->second).first) == _crossNodeMap.end() && _crossNodeMap.find((mi->second).second) == _crossNodeMap.end()) {
	        PeriodicTie<N> * pt = new PeriodicTie<N>((mi->second).first,(mi->second).second,_box,doRelax);
		addConstraint(pt);
		_crossNodeMap.insert(pair<DefNode*,DefNode*>((mi->second).second,(mi->second).first));
		_crossNodeMap.insert(pair<DefNode*,DefNode*>((mi->second).first,(mi->second).first));
		attachedCL = true;
	      }
       
	      mi++;
	    }
	    // 	    if(_crossNodeMap.find(node1A) == _crossNodeMap.end() && _crossNodeMap.find(node2A) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1A,node2A,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2A,node1A));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1A,node1A));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	    // 	    else if(_crossNodeMap.find(node1A) == _crossNodeMap.end() && _crossNodeMap.find(node2B) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1A,node2B,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2B,node1A));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1A,node1A));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	    // 	    else if(_crossNodeMap.find(node1B) == _crossNodeMap.end() && _crossNodeMap.find(node2B) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1B,node2B,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2B,node1B));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1B,node1B));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	    // 	    else if(_crossNodeMap.find(node1B) == _crossNodeMap.end() && _crossNodeMap.find(node2A) == _crossNodeMap.end()) {
	    // 	      PeriodicTie<N> * pt = new PeriodicTie<N>(node1B,node2A,_box);
	    // 	      addConstraint(pt);
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node2A,node1B));
	    // 	      _crossNodeMap.insert(pair< DefNode*, DefNode* >(node1B,node1B));
	    // // 	      std::cout << "Added crosslink # " << _constraints.size() << std::endl;
	    // 	      attachedCL = true;
	    // 	    }
	  }
	}
	ctr2++;
	node2_offset = (node_jump2+ctr2)%(nNodesFil2-1);
      }
      ctr1++;
      node1_offset = (node_jump1+ctr1)%(nNodesFil1-1);
    }
    
    return attachedCL;
  }
  
  template<int N>
  double SemiflexibleGel<N>::crosslinkenergy() {
    double clen = 0.0;
    for(ConstCrosslinkIterator c=_crosslinks.begin(); c!=_crosslinks.end(); c++) {
      clen += (*c)->energy();
    }
    return clen;
  }

  template<int N>
  double SemiflexibleGel<N>::bendingenergy() {
    double ben = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      for(ConstAngleIterator a=((*f)->angles).begin(); a!=((*f)->angles).end(); a++) {
	ben += (*a)->energy();
      }
    }
    return ben;
  }
  
  template<int N>
  double SemiflexibleGel<N>::stretchingenergy() {
    double sten = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      for(ConstBondIterator b=((*f)->bonds).begin(); b!=((*f)->bonds).end(); b++) {
	sten += (*b)->energy();
      }
    }
    return sten;
  }

  template<int N>
  double SemiflexibleGel<N>::parallelenergy() {
    double paren = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      VectorND diff;
      diff = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
      double ang = atan2(diff[1],diff[0]);
      if(abs(cos(ang)) > abs(sin(ang))) {
	for(ConstBondIterator b=((*f)->bonds).begin(); b!=((*f)->bonds).end(); b++) {
	  paren += (*b)->energy();
	}
	for(ConstAngleIterator a=((*f)->angles).begin(); a!=((*f)->angles).end(); a++) {
	  paren += (*a)->energy();
	}
      }
    }
    return paren;
  }

  template<int N>
  double SemiflexibleGel<N>::perpenergy() {
    double perpen = 0.0;
    for(ConstFilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      VectorND diff;
      diff = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
      double ang = atan2(diff[1],diff[0]);
      if(abs(cos(ang)) <= abs(sin(ang))) {
	for(ConstBondIterator b=((*f)->bonds).begin(); b!=((*f)->bonds).end(); b++) {
	  perpen += (*b)->energy();
	}
	for(ConstAngleIterator a=((*f)->angles).begin(); a!=((*f)->angles).end(); a++) {
	  perpen += (*a)->energy();
	}
      }
    }
    return perpen;
  }

  template<int N>
  void SemiflexibleGel<N>::cutOffEndsandCCD(double kcl, DefNodeContainer & dNodes) {
    // compute crosslink dist. and cut off ends //
    int totalCLseps = 0;
    int nNodesBefore = dNodes.size();
    dNodes.clear();
    int nNodesCutOff = 0;
    int id = 0;
    NodeBase::DofIndexMap idx(N);
    if(kcl  > 0.0) {
      int nFils = _filaments.size();
      std::cerr << "Cutting off dangling ends with springy crosslinks not implemented yet!" << std::endl;
      //      for(int i=0; i<nFils; i++) {
      // 	Filament * fcur = filament(i);
      // 	for(std::vector< double >::iterator cls = fcur->clinks.begin()+1; cls!=fcur->clinks.end(); cls++) {
      // 	  double pos_prev = *(cls-1);
      // 	  double pos_cur = *(cls);
      // 	  int curSep = ((int)pos_cur) - ((int)pos_prev);
      // 	  if(_crossDistFreqs.find(curSep) == _crossDistFreqs.end()) {
      // 	    _crossDistFreqs.insert(pair< int, int >(curSep,1));
      // 	  }
      // 	  else {
      // 	    _crossDistFreqs[curSep] += 1;
      // 	  }
      // 	  totalCLseps++;
      // 	  _meanCLsep += (pos_cur - pos_prev);
      // 	}
      //       }
    }
    else {
      int i = 0;
      int nFils = _filaments.size();
      while(i<nFils) {
	Filament * fcur = filament(i);
	bool hitFirstCL = false;
	bool cutOffFirst = false;

	// erase nodes before first crosslink, and also erase angle springs, etc. from filaments //
	while(fcur->nodes.size() > 0 && _crossNodeMap.find(*(fcur->nodes.begin())) == _crossNodeMap.end()) {
	  (fcur->nodes).erase(fcur->nodes.begin());
	  nNodesCutOff++;
	  if(cutOffFirst) {
	    if(fcur->bonds.size() > 0) {
	      fcur->bonds.erase(fcur->bonds.begin());
	    }
	    if(fcur->rods.size() > 0) {
	      fcur->rods.erase(fcur->rods.begin());
	    }
	    if(fcur->angles.size() > 0) {
	      fcur->angles.erase(fcur->angles.begin());
	    }
	  }
	  else cutOffFirst = true;
	}
	if(cutOffFirst) {
	  if(fcur->bonds.size() > 0) {
	    fcur->bonds.erase(fcur->bonds.begin());
	  }
	  if(fcur->rods.size() > 0) {
	    fcur->rods.erase(fcur->rods.begin());
	  }
	  if(fcur->angles.size() > 0) {
	    fcur->angles.erase(fcur->angles.begin());
	  }
	}

	// now erase stuff after last crosslink //
	cutOffFirst = false;
	while(fcur->nodes.size() > 0 && _crossNodeMap.find(*(fcur->nodes.end()-1)) == _crossNodeMap.end()) {
	  (fcur->nodes).erase(fcur->nodes.end()-1);
	  nNodesCutOff++;
	  if(cutOffFirst) {
	    if(fcur->bonds.size() > 0) {
	      fcur->bonds.erase(fcur->bonds.end()-1);
	    }
	    if(fcur->rods.size() > 0) {
	      fcur->rods.erase(fcur->rods.end()-1);
	    }
	    if(fcur->angles.size() > 0) {
	      fcur->angles.erase(fcur->angles.end()-1);
	    }
	  }
	  else cutOffFirst = true;
	}
	if(cutOffFirst) {
	  if(fcur->bonds.size() > 0) {
	    fcur->bonds.erase(fcur->bonds.end()-1);
	  }
	  if(fcur->rods.size() > 0) {
	    fcur->rods.erase(fcur->rods.end()-1);
	  }
	  if(fcur->angles.size() > 0) {
	    fcur->angles.erase(fcur->angles.end()-1);
	  }
	}
	i++;
      }
      
      // now repopulate node container (for solver) with remaining nodes and reset node IDs //
      i = 0;
      while(i<nFils) {
	Filament * fcur = filament(i);
	for(DefNodeIterator fn=fcur->nodes.begin(); fn!=fcur->nodes.end(); fn++) {
	  if(_crossNodeMap.find(*fn) == _crossNodeMap.end() || _crossNodeMap[*fn] == *fn) {
	    dNodes.push_back(*fn);
	    for(int k=0; k<N; k++) {
	      idx[k] = N*id + k;
	    }
	    (*fn)->setId(id);
	    (*fn)->setIndex(idx);
	    id++;
	  }
	  else {
	    DefNode * mastNode = _crossNodeMap[*fn];
	    (*fn)->setId(mastNode->id());
	    (*fn)->setIndex(mastNode->index());
	  }
	}
	if(fcur->nodes.size() > 1) {
	  i++;
	  // check consistency of filament //
	  if(fcur->angles.size() != fcur->nodes.size()-2 || fcur->rods.size() != fcur->nodes.size()-1 || fcur->bonds.size() != fcur->nodes.size()-1) {
	    std::cerr << "# of angles/rods/bonds in filament incorrect after end chop!" << std::endl;
	  }
	  else {
	    int nn = 0;
	    for(AngleIterator ai = fcur->angles.begin(); ai != fcur->angles.end(); ai++) {
	      if((*ai)->baseNodes()[0] != fcur->nodes[nn] || (*ai)->baseNodes()[1] != fcur->nodes[nn+1] || (*ai)->baseNodes()[2] != fcur->nodes[nn+2]) {
		std::cerr << "Angle springs are messed up" << std::endl;
	      }
	      nn++;
	    }
	    nn = 0;
	    for(BondIterator bi = fcur->bonds.begin(); bi != fcur->bonds.end(); bi++) {
	      if((*bi)->baseNodes()[0] != fcur->nodes[nn] || (*bi)->baseNodes()[1] != fcur->nodes[nn+1]) {
		std::cerr << "Bond springs are messed up" << std::endl;
	      }
	      nn++;
	    }
	    nn = 0;
	    for(RodIterator ri = fcur->rods.begin(); ri != fcur->rods.end(); ri++) {
	      if((*ri)->baseNodes()[0] != fcur->nodes[nn] || (*ri)->baseNodes()[1] != fcur->nodes[nn+1]) {
		std::cerr << "Brownian rods are messed up" << std::endl;
	      }
	      nn++;
	    }
	  }
	}
	else {
	  if(fcur->nodes.size()==0) {
	    std::cout << "Filament with 0 nodes encountered; removing filament." << std::endl;
	    nFils--;
	    FilamentIterator fi = _filaments.begin();
	    _filaments.erase(fi+i);
	  }
	  else {
	    if(fcur->angles.size() !=0 || fcur->bonds.size()!=0 || fcur->rods.size()!=0) {
	      std::cerr << "# of angles/rods/bonds in filament incorrect after end chop!" << std::endl;
	    }
	    std::cout << "Filament with 1 node encountered; keeping filament." << std::endl;
	    i++;
	  }
	}
      }
    }
    std::cout << "Consistency check: beginning # of nodes = " << nNodesBefore << ", # of nodes cut off = " << nNodesCutOff << ", so expected size of container = " 
	      << nNodesBefore-nNodesCutOff << "; actual size of container = " << dNodes.size() << "." << std::endl;
  }

  template<int N>
  std::map< std::pair<double,double>, std::pair<double,double> > SemiflexibleGel<N>::getAngularEnergyDistro() {
    compute(true,false,false);
    std::cout << "Energy check: gel energy = " << _energy << std::endl;
    double minl = 0.0;
    double maxl = M_PI;
    double stdd = 0.0;
    double avgAng = 0.0;
    int nFils = _filaments.size();
    std::multimap<double, Filament *> filAngles;
    //std::multimap<double,double> angEnergies;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      VectorND e2e;
      e2e = fil->nodes[fil->nodes.size()-1]->position() - fil->nodes[0]->position();
      double ang = atan2(e2e[1],e2e[0]);
      if(ang<0.0) ang += M_PI;
      //double filEner = 0.0;
      //for(BondIterator bi=fil->bonds.begin(); bi!=fil->bonds.end(); bi++) {
      //filEner += (*bi)->energy();
      //}
      //for(AngleIterator ai=fil->angles.begin(); ai!=fil->angles.end(); ai++) {
      //filEner += (*ai)->energy();
      //}
      //filEner /= _energy;
      ///angEnergies.insert(pair<double,double>(ang,filEner));
      filAngles.insert(pair<double,Filament *>(ang,fil));
      avgAng += ang/nFils;
      stdd += sqr(ang)/nFils;
    }
    stdd = stdd - sqr(avgAng);
    stdd = sqrt(stdd);
    //double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
    //int nBins = (int)(floor((maxl-minl)/binwidth)+.5);
    int nBins = 18;
    double checkEner = 0.0;
    double binwidth = (maxl-minl)/nBins;
    double minVal = minl;
    std::map< doublePair, doublePair > angEnergyMap;
    for(int i=0; i<nBins; i++) {
      typename std::multimap<double,Filament*>::iterator lenIt;
      typename std::multimap<double,Filament*>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = filAngles.lower_bound(curHigh);
      double meanAng = 0.0;
      double totEner = 0.0;
      double bendEner = 0.0;
      double stretchEner = 0.0;
      int nPts = 0;
      for(lenIt = filAngles.begin(); lenIt!=lenItHigh; lenIt++) {
	meanAng += lenIt->first;
	double filEner = 0.0;
	for(BondIterator bi=lenIt->second->bonds.begin(); bi!=lenIt->second->bonds.end(); bi++) {
	  filEner += (*bi)->energy();
	  stretchEner +=(*bi)->energy();
	}
	for(AngleIterator ai=lenIt->second->angles.begin(); ai!=lenIt->second->angles.end(); ai++) {
	  filEner += (*ai)->energy();
	  bendEner += (*ai)->energy();
	}
	totEner += filEner;
	nPts++;
      }
      meanAng /= nPts;
      double dnPts = (double)(nPts);
      doublePair angPair = pair<double, double>(meanAng,totEner);
      doublePair enerPair = pair<double, double>(bendEner,stretchEner);
      angEnergyMap.insert(pair<doublePair,doublePair>(angPair,enerPair));
      filAngles.erase(filAngles.begin(),lenItHigh);
    }

    assert(filAngles.size()==0);

    return angEnergyMap;
  }

  template<int N>
  std::multimap< double, std::vector<double> > SemiflexibleGel<N>::getDensityEnergyDistro(double scale) {
    VectorND sysSize;
    sysSize = _box->size();
    int nBoxesX = (int)(sysSize[0]/scale);
    int nBoxesY = (int)(sysSize[1]/scale);
    VectorND gridSizes;
    gridSizes[0] = sysSize[0]/nBoxesX;
    gridSizes[1] = sysSize[1]/nBoxesY;
    
    double lengthdens[nBoxesX][nBoxesY];
    double bendenergs[nBoxesX][nBoxesY];
    double stretchenergs[nBoxesX][nBoxesY];
    for(int nx=0; nx<nBoxesX; nx++) {
      for(int ny=0; ny<nBoxesY;ny++) {
	lengthdens[nx][ny] = 0.0;
	bendenergs[nx][ny] = 0.0;
	stretchenergs[nx][ny] = 0.0;
      }
    }
    
    multimap< double, vector<double> > finalData;

    int nF = _filaments.size();
    for(int i=0; i<nF; i++) {
      Filament * f = filament(i);
      int nNodes = f->nodes.size();
      for(int j=0; j<nNodes-1; j++) {
	DefNode * node1 = f->nodes[j];
	DefNode * node2 = f->nodes[j+1];
	VectorND com;
	com = .5*(node1->position() + node2->position());
	int nxbox = (int)(com[0]/gridSizes[0]);
	int nybox = (int)(com[1]/gridSizes[1]);
	if(nxbox<nBoxesX && nybox<nBoxesY) {
	  double bondLength = norm2(node1->position()-node2->position());
	  lengthdens[nxbox][nybox] += bondLength;
	  stretchenergs[nxbox][nybox] += f->bonds[j]->energy();
	}
      }
      for(int j=1; j<nNodes-1; j++) {
	DefNode * node1 = f->nodes[j];
	DefNode * node2 = f->nodes[j+1];
	VectorND com;
	com = node1->position();
	int nxbox = (int)(com[0]/gridSizes[0]);
	int nybox = (int)(com[1]/gridSizes[1]);
	if(nxbox<nBoxesX && nybox<nBoxesY) {
	  bendenergs[nxbox][nybox] += f->angles[j-1]->energy();
	}
      }
    }
    
    for(int nx=0; nx<nBoxesX; nx++) {
      for(int ny=0; ny<nBoxesY;ny++) {
	std::vector<double> ens;
	double totalE = bendenergs[nx][ny] + stretchenergs[nx][ny];
	ens.push_back(totalE);
	ens.push_back(bendenergs[nx][ny]);
	ens.push_back(stretchenergs[nx][ny]);
	double lengthDens = lengthdens[nx][ny]/(gridSizes[0]*gridSizes[1]);
	finalData.insert(pair< double, vector<double> >(lengthDens,ens));
      }
    }

    return finalData;
  }

  template<int N>
  std::vector< std::pair<double, double> > SemiflexibleGel<N>::energyCorrelationFunction(double boxs, double maxlen) {
    std::vector< std::pair<double, double> > enCorrs;

    VectorND boxsize;
    for(int i=0; i<N; i++) boxsize[i] = boxs;
    tvmet::Vector<int,N> nCells;
    int nBoxes = 1;
    for(int i=0; i<N; i++) {
      nCells[i] = (int)(_box->size()[i]/boxsize[i]);
      boxsize[i] = _box->size()[i]/nCells[i];
      nBoxes *= nCells[i];
    }
    
    tvmet::Vector<int,N> mults;
    int curMult = nBoxes;
    for(int i=0; i<N; i++) {
      curMult /= nCells[i];
      mults[i] = curMult;
    }
    
    std::vector<double> energies(nBoxes);
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      for(int b=0; b<nNodes-1; b++) {
	VectorND com;
	com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
// 	std::cout << "Troubleshoot: coords = (" 
// 		  << coords[0] << ", " << coords[1] << "); index = " 
// 		  << idx << "; grid dimensions = ("
// 		  << nCells[0] << ", " << nCells[1] << ")."
// 		  << std::endl;
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->bonds[b]->energy();
      }
      for(int a=1; a<nNodes-1; a++) {
	VectorND com;
	com = (*f)->nodes[a]->position();
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->angles[a-1]->energy();
      }
    }

    double minr = 0.0;
    double maxr = maxlen;
    double stepr = 2.0*max(boxsize[0],boxsize[1]);
    int nSteps = (int)((maxr-minr)/stepr);
    VectorND curGridSize;
    VectorND oldGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = stepr + 0.5*max(boxsize[0],boxsize[1]);
    oldGridSize = curGridSize;

    std::map<DefNode*,double> enmap;

    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(curGridSize);
    nodegrid->setComputeNeighbors(false);

    curGridSize = nodegrid->gridSpace();

    NodeBase::DofIndexMap doidx(N);

    double meanen = 0.0;
    double corrval = 0.0;
    for(int nn=0; nn<nBoxes; nn++) {
      tvmet::Vector<int,N> coords;
      VectorND centpos;
      int nnleft = nn;
      for(int k=0; k<N; k++) {
	doidx[k] = nn*N + k;
	coords[k] = nnleft/mults[k];
	nnleft = nnleft - mults[k]*coords[k];
	centpos[k] = (coords[k]+.5)*boxsize[k];
      }
      meanen += energies[nn];

//       std::cout << "Troubleshoot: index = "
// 		<< nn << "; coords = ("
// 		<< coords[0] << ", " << coords[1] << ")."
// 		<< std::endl;

      DefNode * newNode = new BrownianNode<N>(nn,doidx,centpos,centpos);
      newNode->setId(nn);
      enmap.insert(pair<DefNode*,double>(newNode,energies[nn]));
      nodegrid->addElem(newNode);
    }
    meanen /= nBoxes;

    for(int nn=0; nn<nBoxes; nn++) corrval += sqr(energies[nn]-meanen);
    corrval /= nBoxes;
    
    std::pair<double, double> firstPair = pair<double, double>(0.0,corrval);
    enCorrs.push_back(firstPair);
    
    // get pairs, compute corrval, repeat with different grid sizes
    for(int ns=1; ns<=nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      oldGridSize = curGridSize;
      double curdist = ns*stepr;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + 0.5*max(boxsize[0],boxsize[1]);
      nodegrid->resetGridSpace(curGridSize);
      curGridSize = nodegrid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + 0.5*max(boxsize[0],boxsize[1]));
      int nGridBoxes = nodegrid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< DefNode*, std::set<DefNode*> > pairs = nodegrid->getNeighbors(nb);
	for(typename map< DefNode*, set<DefNode*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  DefNode* node1 = pairit->first;
	  for(typename set<DefNode*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    DefNode* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->position() - node2->position();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < 0.5*max(boxsize[0],boxsize[1])) {
		nSamps++;
		corrval += (enmap[node1]-meanen)*(enmap[node2]-meanen);
	      }
	    }
	  }
	}
      }
      corrval /= nSamps;
      std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
      enCorrs.push_back(curPair);
    }
    
    for(typename map<DefNode*,double>::iterator ni=enmap.begin(); ni!=enmap.end(); ni++) {
      delete ni->first;
    }

    return enCorrs;
  }


  template<int N>
  void SemiflexibleGel<N>::computeCrossDistro(double kcl) {
    _meanCLsep = 0.0;
    double stdd = 0.0;
    int totalCLseps = 0;
    _crossDistFreqs.clear();
    int nFils = _filaments.size();
    if(kcl  > 0.0) {
      for(int i=0; i<nFils; i++) {
	Filament * fcur = filament(i);
	for(std::vector< double >::iterator cls = fcur->clinks.begin()+1; cls!=fcur->clinks.end(); cls++) {
	  double pos_prev = *(cls-1);
	  double pos_cur = *(cls);
	  int curSep = ((int)pos_cur) - ((int)pos_prev);
	  if(_crossDistFreqs.find(curSep) == _crossDistFreqs.end()) {
	    _crossDistFreqs.insert(pair< int, int >(curSep,1));
	  }
	  else {
	    _crossDistFreqs[curSep] += 1;
	  }
	  totalCLseps++;
	  _meanCLsep += (pos_cur - pos_prev);
	}
      }
    }
    else {
      std::multiset<double> clLengths;
      double maxl = -1.0;
      double minl = 1.0e30;
      for(int i=0; i<nFils; i++) {
	Filament * fcur = filament(i);
	double curDist;
	bool hitFirstCL = false;
	int nNodesHere = fcur->nodes.size();
	for(int fn=0; fn<nNodesHere; fn++) {
	  DefNode* dn = fcur->nodes[fn];
	  if(_crossNodeMap.find(dn) != _crossNodeMap.end() || _crosslinkNodes.find(dn) != _crosslinkNodes.end()) {
	    if(hitFirstCL) {
	      _meanCLsep += curDist;
	      stdd += sqr(curDist);
	      clLengths.insert(curDist);
	      if(curDist < minl) minl = curDist;
	      if(curDist > maxl) maxl = curDist;
	      if(fn!=nNodesHere-1) curDist = fcur->bonds[fn]->getLength();
	      if(dn == _crossNodeMap[dn]) {
                int nclsHere = _nSlavesMap[dn]-1;
		for(int icl=0; icl<nclsHere; icl++) clLengths.insert(0.0);
              }
	    }
	    else {
	      if(fn!=nNodesHere-1) curDist = fcur->bonds[fn]->getLength();
	      hitFirstCL = true;
	      if(dn == _crossNodeMap[dn]) {
                int nclsHere = _nSlavesMap[dn]-1;
		for(int icl=0; icl<nclsHere; icl++) clLengths.insert(0.0);
              }
            }
	  }
	  else {
	    if(hitFirstCL) {
	      if(fn!=nNodesHere-1) curDist += fcur->bonds[fn]->getLength();
	    }
	  }
	}
      }
      totalCLseps = clLengths.size();
      stdd /= totalCLseps;
      stdd = stdd - sqr(_meanCLsep/totalCLseps);
      stdd = sqrt(stdd);
      double binwidth = 3.49*stdd/pow(totalCLseps,1.0/3.0);
      int nBins = (int)((maxl-minl)/binwidth) + 2;
      double minVal = minl-.5*binwidth;
      for(int i=0; i<nBins; i++) {
        multiset<double>::iterator lenItHigh;
        double curHigh = minVal + (i+1.0)*binwidth;
        lenItHigh = clLengths.lower_bound(curHigh);
        int numPts = clLengths.size();
        clLengths.erase(clLengths.begin(),lenItHigh);
        _crossDistFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-clLengths.size()));
      }

      assert(clLengths.size()==0);

    }
    _meanCLsep /= totalCLseps;
  }

  template<int N>
  void SemiflexibleGel<N>::computeFilLenDistro() {
    _filLenFreqs.clear();
    _meanFilLen = 0.0;
    double stdd = 0.0;
    double minl = 1.0e30;
    double maxl = -1.0;
    int nFils = _filaments.size();
    std::multiset<double> filLengths;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      double dist = 0.0;
      for(BondIterator bi=fil->bonds.begin(); bi!=fil->bonds.end(); bi++) {
	dist += (*bi)->getLength();
      }
      filLengths.insert(dist);
      if(dist < minl) minl = dist;
      if(dist > maxl) maxl = dist;
      _meanFilLen += dist/nFils;
      stdd += sqr(dist)/nFils;
    }
    stdd = stdd - sqr(_meanFilLen);
    stdd = sqrt(stdd);
    double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
    int nBins = (int)((maxl-minl)/binwidth) + 2;
    double minVal = minl-.5*binwidth;
    for(int i=0; i<nBins; i++) {
      multiset<double>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = filLengths.lower_bound(curHigh);
      int numPts = filLengths.size();
      filLengths.erase(filLengths.begin(),lenItHigh);
      _filLenFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-filLengths.size()));
    }

    assert(filLengths.size()==0);
  }

  template<int N>
  void SemiflexibleGel<N>::computeFilStreStiffDistro() {
    _filStreStiffFreqs.clear();
    _meanFilStreStiff = 0.0;
    double stdd = 0.0;
    double mins = 1.0e30;
    double maxs = -1.0;
    int nFils = _filaments.size();
    std::multiset<double> filStiffs;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      double mu = 0.0;
      for(BondIterator bi=fil->bonds.begin(); bi!=fil->bonds.end(); bi++) {
	mu += (*bi)->getLength()*(*bi)->stiffness();
      }
      mu /= fil->bonds.size();
      filStiffs.insert(mu);
      if(mu < mins) mins = mu;
      if(mu > maxs) maxs = mu;
      _meanFilStreStiff += mu/nFils;
      stdd += sqr(mu)/nFils;
    }
    stdd = stdd - sqr(_meanFilStreStiff);
    if ( stdd < 1.0e-4){//stiffnesses are same, just output the mean stiffness
      _filStreStiffFreqs.insert(pair<double,int>(_meanFilStreStiff,filStiffs.size()));
      filStiffs.erase(filStiffs.begin(),filStiffs.end());
    }
    else {
      stdd = sqrt(stdd);
      double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
      int nBins = (int)((maxs-mins)/binwidth) + 2;
      double minVal = mins-.5*binwidth;
      for(int i=0; i<nBins; i++) {
	multiset<double>::iterator lenItHigh;
	double curHigh = minVal + (i+1.0)*binwidth;
	lenItHigh = filStiffs.lower_bound(curHigh);
	int numPts = filStiffs.size();
	filStiffs.erase(filStiffs.begin(),lenItHigh);
	_filStreStiffFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-filStiffs.size()));
      }
    }

    assert(filStiffs.size()==0);
  }

  template<int N>
  void SemiflexibleGel<N>::computeFilBendStiffDistro() {
    _filBendStiffFreqs.clear();
    _meanFilBendStiff = 0.0;
    double stdd = 0.0;
    double mins = 1.0e30;
    double maxs = -1.0;
    int nFils = _filaments.size();
    std::multiset<double> filStiffs;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      double kappa = 0.0;
      for(AngleIterator ai=fil->angles.begin(); ai!=fil->angles.end(); ai++) {
	kappa += (*ai)->meanSegmentLength()*(*ai)->stiffness();
      }
      kappa /= fil->angles.size();
      filStiffs.insert(kappa);
      if(kappa < mins) mins = kappa;
      if(kappa > maxs) maxs = kappa;
      _meanFilBendStiff += kappa/nFils;
      stdd += sqr(kappa)/nFils;
    }
    stdd = stdd - sqr(_meanFilBendStiff);
    if ( stdd < 1.0e-4){//stiffnesses are same, just output the mean stiffness
      _filBendStiffFreqs.insert(pair<double,int>(_meanFilBendStiff,filStiffs.size()));
      filStiffs.erase(filStiffs.begin(),filStiffs.end());
    }
    else {
      stdd = sqrt(stdd);
      double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
      int nBins = (int)((maxs-mins)/binwidth) + 2;
      double minVal = mins-.5*binwidth;
      for(int i=0; i<nBins; i++) {
	multiset<double>::iterator lenItHigh;
	double curHigh = minVal + (i+1.0)*binwidth;
	lenItHigh = filStiffs.lower_bound(curHigh);
	int numPts = filStiffs.size();
	filStiffs.erase(filStiffs.begin(),lenItHigh);
	_filBendStiffFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-filStiffs.size()));
      }
    }
    assert(filStiffs.size()==0);
  }

  template<int N>
  void SemiflexibleGel<N>::computeNematicOP() {
    double nemOP;
    VectorND nemDirector;
    if(N==2) {
      Tensor2D nemTensor(0.0);
      int nFils = _filaments.size();
      for(int i=0; i<nFils; i++) {
	Filament * fil = filament(i);
	VectorND e2e;
	e2e = fil->nodes[fil->nodes.size()-1]->point() - fil->nodes[0]->point();
	double ang = atan2(e2e[1],e2e[0]);
	nemTensor(0,0) += (2.0*sqr(cos(ang)) - 1.0)/nFils;
	nemTensor(1,1) += (2.0*sqr(sin(ang)) - 1.0)/nFils;
	nemTensor(0,1) += (2.0*cos(ang)*sin(ang))/nFils;
      }
      nemTensor(1,0) = nemTensor(0,1);
      
      // now solve for largest eigenvalue and associated eigenvector //
      double lam1 = .5*(nemTensor(0,0)+nemTensor(1,1) + sqrt(sqr(nemTensor(0,0)-nemTensor(1,1))+sqr(2.0*nemTensor(0,1))));
      //double lam2 = .5*(nemTensor(0,0)+nemTensor(1,1) - sqrt(sqr(nemTensor(0,0)-nemTensor(1,1))+sqr(2.0*nemTensor(0,1))));
      nemOP = lam1;
      double v1 = 1.0/sqrt(1.0 + sqr((nemTensor(0,0)+nemTensor(0,1)-lam1)/(nemTensor(1,1)+nemTensor(0,1)-lam1)));
      double v2 = -v1*(nemTensor(0,0)+nemTensor(0,1)-lam1)/(nemTensor(1,1)+nemTensor(0,1)-lam1);
      nemDirector[0] = v1;
      nemDirector[1] = v2;
    }

    _nematicOP = nemOP;
    _nemDirector = nemDirector;
  }

  template<int N>
  void SemiflexibleGel<N>::computeNematicDistro(double nemAngle) {
    _nematicFreqs.clear();
    _nematicOP = 0.0;
    double avgAng = 0.0;
    double stdd = 0.0;
    double minl = -M_PI;
    double maxl = M_PI;
    int nFils = _filaments.size();
    std::multiset<double> filAngles;
    for(int i=0; i<nFils; i++) {
      Filament * fil = filament(i);
      VectorND e2e;
      e2e = fil->nodes[fil->nodes.size()-1]->point() - fil->nodes[0]->point();
      double ang = atan2(e2e[1],e2e[0]);
      ang -= nemAngle;
      if(ang <= -M_PI) ang += 2.0*M_PI;
      else if(ang > M_PI) ang -= 2.0*M_PI;
      assert(fabs(ang) <= M_PI);
      filAngles.insert(ang);
      _nematicOP += cos(2.0*ang)/nFils;
      avgAng += ang/nFils;
      stdd += sqr(ang)/nFils;
    }
    stdd = stdd - sqr(avgAng);
    stdd = sqrt(stdd);
    double binwidth = 3.49*stdd/pow(nFils,1.0/3.0);
    int nBins = (int)(floor((maxl-minl)/binwidth)+.5);
    binwidth = (maxl-minl)/nBins;
    double minVal = minl;
    for(int i=0; i<nBins; i++) {
      multiset<double>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = filAngles.lower_bound(curHigh);
      int numPts = filAngles.size();
      filAngles.erase(filAngles.begin(),lenItHigh);
      _nematicFreqs.insert(pair<double,int>(curHigh-.5*binwidth,numPts-filAngles.size()));
    }

    assert(filAngles.size()==0);
  }

  //   template<int N>
  //   bool SemiflexibleGel<N>::checkCrosslinks() {
  //     // make sure filaments are not doubly-crosslinked //
  //     bool err = false;
  //     int totCL = 0;
  //     for(int i=0; i<_filaments.size(); i++) {
  //       Filament* f1 = filament(i);
  //       DefNodeContainer mastNodes;
  //       for(int n1=0; n1<f1->nodes.size(); n1++) {
  // 	if(_crossNodeMap.find(f1->nodes[n1]) != _crossNodeMap.end()) {
  // 	  mastNodes.push_back(_crossNodeMap[f1->nodes[n1]]);
  // 	}
  //       }
  //       for(int j=i+1; j<_filaments.size(); j++) {
  // 	Filament* f2 = filament(j);
  // 	int nConnex = 0; // number of crosslinks between filaments //
  // 	for(int n2=0; n2<f2->nodes.size(); n2++) {
  // 	  DefNode* curMast;
  // 	  if(_crossNodeMap.find(f2->nodes[n2]) != _crossNodeMap.end()) {
  // 	    curMast = _crossNodeMap[f2->nodes[n2]];
  // 	    for(int ncl=0; ncl<mastNodes.size(); ncl++) {
  // 	      if(mastNodes[ncl] == curMast) {
  // 		nConnex++;
  // 		totCL++;
  // 	      }
  // 	    }
  // 	  }
  // 	}
  // 	if(nConnex>1) {
  // 	  std::cout << "Error: filaments " << i << " and " << j << " are crosslinked " << nConnex << " times." << std::endl;
  // 	  err = true;
  // 	}
  // 	else if(nConnex==1) std::cout << "Filaments " << i << " and " << j << " are crosslinked " << nConnex << " times." << std::endl;
  //       }
  //     }
  //     if(!err) {
  //       std::cout << "All filaments linked 0 or 1 times!" << std::endl << "Total # of crosslinks = " << totCL << "." << std::endl;
  //     }
  //     return err;
  //   }
  //   template<int N>
  //   std::vector< pair< double, double > > & SemiflexibleGel<N>::getAffinityMeasure(double step, double max) {
  //     int nFils = _filaments.size();
  //     std::vector< pair< double, double > > affins;
  //     affins.reserve(max/step+1);
  //     for(int count=0; count<=max/step; count++) {
  //       affins.push_back(pair< double, double >(count*step,0.0));
  //     }
  //     for(int i=0; i<nFils; i++) {
  //       Filament * fcur = filament(i);
  //       for(int j=0; j<=i; j++) {
  // 	Filament * fcur2 = filament(j);
  // 	for(DefNodeIterator fn1=fcur->nodes.begin(); fn1!=fcur->nodes.end(); fn1++) {
  // 	  for(DefNodeIterator fn2=fcur2->nodes.begin(); fn2!=fcur2->nodes.end(); fn2++) {
  // 	    bool sepHit = false;
  // 	    while(!sepHit) {
	      
  // 	    }
  // 	  }
  // 	}
  //       }
  //     }
  //   }

  template<int N>
  void SemiflexibleGel<N>::printAngles(std::string & angleFile) {
    std::vector<double> angs;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      if((*fi)->nodes.size() > 1) {
	int nNodes = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNodes-1]->position() - (*fi)->nodes[0]->position();
	double ang = atan2(e2e[1],e2e[0]);
	angs.push_back(ang);
      }
    }
    std::ofstream angFile(angleFile.c_str());
    for(vector<double>::iterator ai=angs.begin(); ai!=angs.end(); ai++) {
      angFile << *ai << std::endl;
    }
    angFile.close();
  }

    template<int N>
  std::vector< pair<double,double> > SemiflexibleGel<N>::affineMeasurement(double minLength, double stepSize, double maxLength, double shear, std::string measureType) {
    double affrot = shear/2.0;
    double affshear = shear/2.0;
    doublePairContainer affmeas;
    DefNodeContainer nodes4triangulation;
    // add nodes to container for triangulation //
    Vector2D maxPos(_box->size());
    Vector2D minPos(0.0);
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	if((*dni)->position()[0] > maxPos[0]) maxPos[0] = (*dni)->position()[0];
	if((*dni)->position()[1] > maxPos[1]) maxPos[1] = (*dni)->position()[1];
	if((*dni)->position()[0] < minPos[0]) minPos[0] = (*dni)->position()[0];
	if((*dni)->position()[1] < minPos[1]) minPos[1] = (*dni)->position()[1];
      }
    }

    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
// 	if(isMaster(*dni)) {
// 	  Vector2D tmpPos;
// 	  Vector2D tmpDef;
// 	  tmpPos = (*dni)->position();
// 	  tmpDef = (*dni)->point() - (*dni)->position();
// 	  _box->mapPoint(tmpPos);
// 	  tmpDef += tmpPos;
// 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
// 	  newNode->setId((*dni)->id());
// 	  nodes4triangulation.push_back(newNode);
// 	}
	if(!isSlave(*dni)) {
	  Vector2D tmpPos;
	  Vector2D tmpDef;
// 	  tmpPos = (*dni)->position() - minPos;
// 	  tmpDef = (*dni)->point() - minPos;
	  tmpPos = (*dni)->position();
	  _box->setShear(0.0);
	  _box->mapPoint(tmpPos);
	  tmpDef = (*dni)->point() - tmpPos;
	  _box->setShear(shear);
	  _box->mapDistance(tmpDef);
	  tmpDef += tmpPos;
	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	  newNode->setId((*dni)->id());
	  nodes4triangulation.push_back(newNode);
	}
      }
    }
    _box->setShear(0.0);
    
    // do triangulation with original set of nodes //
    AffinityMeasure* am = new AffinityMeasure(nodes4triangulation);
    am->triangulate();
    //StrainField sf;
    //sf = am->getStrainField();

    am->printParaview("mesh-0.0");
    
    // compute non-affinity measure for this coarse-graining scale //
    if(measureType == "strain") {
      affmeas.push_back(pair<double, double>(0.0,am->strainMeasure(shear,_box->size()[0]*_box->size()[1])));
    }
    else if(measureType == "rotation") {
      affmeas.push_back(pair<double, double>(0.0,am->rotationMeasure(affrot,_box->size()[0]*_box->size()[1])));
    }
    
    // figure out how many different box sizes to use //
    //int nSteps = (int)(log2(syssize/(2.0*minLength)));
    int nSteps = (int)((maxLength-minLength)/stepSize);

    // create new grid with nodes' position (not point) as relevant location //
    Vector2D gridSpace;
    gridSpace[0] = minLength;
    gridSpace[1] = minLength;
    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    PeriodicBox tmpBox(0.0,0.0);
    Vector2D boxSize;
    boxSize = maxPos - minPos;
    tmpBox.setSize(boxSize);
    nodegrid->setBox(_box);
    //nodegrid->setBox(&tmpBox);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(gridSpace);
    nodegrid->setComputeNeighbors(false);
    nodegrid->addElems(nodes4triangulation);
    

    double oldGridSize = 0.0;
    Vector2D oldGridSpace(0.0);
    bool printOut;
    for(int j=0; j<nSteps; j++) {
      // get new grid size, reset grid spacing, and add new elements //
      //double gridSize = minLength*pow(2.0,j);
      double gridSize = minLength + j*stepSize;
      for(int i=0; i<2; i++) gridSpace[i] = gridSize;
      std::cout << "Resetting grid spacing...";
      nodegrid->resetGridSpace(gridSpace);
      gridSpace = nodegrid->gridSpace();
      gridSize = gridSpace[0];
      if(abs(gridSpace[0]-oldGridSpace[0]) < 1.0e-6 || abs(gridSpace[1]-oldGridSpace[1]) < 1.0e-6) printOut = false;
      else printOut = true;
      oldGridSize = gridSize;
      oldGridSpace = gridSpace;
      std::cout << "new grid size = (" << gridSpace[0] << ", " << gridSpace[1] << ")" << std::endl;
      //nodegrid->addElems(nodes4triangulation);
      // get vector of boxes //
      std::vector< std::set<DefNode*> > & nodeBoxes = nodegrid->elemBoxes();
      int nBoxes = nodeBoxes.size();
      DefNodeContainer tmpContainer;
      // for each box, compute mean position and mean displacement vector and create new node //
      for(int boxit=0; boxit<nBoxes; boxit++) {
	Vector2D newPos(0.0,0.0);
	Vector2D newPoint(0.0,0.0);
	int nNodesHere = nodeBoxes[boxit].size();
	if(nNodesHere>0) {
	  for(typename std::set<DefNode*>::iterator nodeit=nodeBoxes[boxit].begin(); nodeit!=nodeBoxes[boxit].end(); nodeit++) {
	    newPos += (*nodeit)->position();
	    newPoint += (*nodeit)->point();
	  }
	  newPos /= nNodesHere;
	  newPoint /= nNodesHere;
	  NodeBase::DofIndexMap idx(N);
	  for(int k=0; k<N; k++) idx[k] = boxit*N + k;
	  DefNode* newNode = new BrownianNode<2>(boxit,idx,newPos,newPoint);
	  newNode->setId(boxit);
	  tmpContainer.push_back(newNode);
	}
      }
      
      // now pass new vector of nodes to triangulation routine //
      //am->resetNodes(tmpContainer);
      //am->triangulate();
      //sf = am->getStrainField();

      am->resetNodes(tmpContainer);
      am->triangulate();
      //sf = am2.getStrainField();
      char fname[128];
      sprintf(fname,"mesh-%g",gridSize);
      am->printParaview(fname);
      
      // compute non-affinity measure for this coarse-graining scale //
      double avgGridSize = .5*(gridSpace[0] + gridSpace[1]);
      if(measureType == "strain" && printOut) {
	affmeas.push_back(pair<double, double>(avgGridSize,am->strainMeasure(shear,100.0*gridSpace[0]*gridSpace[1])));
      }
      else if(measureType == "rotation" && printOut) {
	affmeas.push_back(pair<double, double>(avgGridSize,am->rotationMeasure(affrot,100.0*gridSpace[0]*gridSpace[1])));
      }
      
      // delete temporary nodes //
      for(DefNodeIterator dni=tmpContainer.begin(); dni!=tmpContainer.end(); dni++) delete *dni;
    }
    

    for(DefNodeIterator dni2=nodes4triangulation.begin(); dni2!=nodes4triangulation.end(); dni2++) delete *dni2;

    return affmeas;
  }

  template<int N>
  void SemiflexibleGel<N>::computeNonaffinityLengthDensityCorrelation(double boxsize, double maxdist, double maxFL, double shear) {
    double affrot = shear/2.0;
    double affshear = shear/2.0;
    doublePairContainer affmeas;
    DefNodeContainer nodes4triangulation;
    // add nodes to container for triangulation //
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool isLong = false;
      VectorND e2e;
      e2e = (*fi)->nodes[(*fi)->nodes.size()-1]->position() - (*fi)->nodes[0]->position();
      if(norm2(e2e) > maxFL) isLong = true;
      if(!isLong) {
	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	  if(!isSlave(*dni)) {
	    VectorND pos;
	    pos = (*dni)->position();
	    _box->setShear(0.0);
	    _box->mapPoint(pos);
	    VectorND dev;
	    dev = (*dni)->point() - pos;
	    _box->setShear(shear);
	    _box->mapDistance(dev);
	    _box->setShear(0.0);
	    VectorND pt;
	    pt = pos+dev;
	    
	    DefNode* newNode = new BrownianNode<N>((*dni)->id(),(*dni)->index(),pos,pt);
	    nodes4triangulation.push_back(newNode);
	  }
	}
      }
    }

    _box->setShear(0.0);
    
    // do triangulation with original set of nodes //
    AffinityMeasure* am = new AffinityMeasure(nodes4triangulation);
    am->triangulate();
    am->printParaview("mesh");
    //StrainField sf;
    //sf = am->getStrainField();

    //am->printParaview("mesh-0.0");
    
    // compute non-affinity measure for this coarse-graining scale //
//     if(measureType == "strain") {
//       affmeas.push_back(pair<double, double>(0.0,am->strainMeasure(shear,_box->size()[0]*_box->size()[1])));
//     }
//     else if(measureType == "rotation") {
//       affmeas.push_back(pair<double, double>(0.0,am->rotationMeasure(affrot,_box->size()[0]*_box->size()[1])));
//     }  


    double meanrot = 0.0;
    double stddevrot = 0.0;
    double totalArea = 0.0;
    std::vector<AffinityElement *> & els = am->getElements();
    for(typename vector<AffinityElement *>::iterator afi=els.begin(); afi!=els.end(); afi++) {
      double newval = sqr((*afi)->Rotation()-(shear/2.0));
      double newarea = (*afi)->Area();
      meanrot += newval*newarea;
      stddevrot += sqr(newval)*newarea;
      totalArea += newarea;
    }
    meanrot /= totalArea;
    stddevrot /= totalArea;
    stddevrot -= sqr(meanrot);
    stddevrot = sqrt(stddevrot);
    std::cout << "Mean squared deviation from affine rotational part = " << meanrot << "; width of distribution = " << stddevrot << "." << std::endl;

    std::cout << "Do you want to compute the nonaffinity-nonaffinity correlation function using the triangulated values of the rotation?\n(1) yes\n(2) no\n\n: ";
    int doCorrTriangle;
    std::cin >> doCorrTriangle;
    if(doCorrTriangle == 1) {
      double avgarea = totalArea/els.size();
      double minlength = 2.0*sqrt(avgarea);
      std::map<DefNode*,double> affTriangleMap;
      for(int nt=0; nt<els.size(); nt++) {
	NodeBase::DofIndexMap idx(N);
	for(int kdof=0; kdof<N; kdof++) idx[kdof] = nt*N + kdof;
	const Vector2D & centr = els[nt]->Centroid(); 
	DefNode* newNode2 = new BrownianNode<2>(nt,idx,centr,centr);
	double affdev = sqr(els[nt]->Rotation()-(shear/2.0));
	affTriangleMap.insert(pair<DefNode*,double>(newNode2,affdev));
      }

      std::vector< pair<double,double> > affTriangleData = computeCorrelationFunction(affTriangleMap,minlength,maxdist,2.0*minlength,minlength/2.0);
      
      std::cout << "Please enter the name of a file in which to put the data: ";
      char tricorrFN[256];
      std::cin >> tricorrFN;
      
      std::ofstream tac(tricorrFN);
      tac << "#r\tcorr" << std::endl;
      
      for(typename std::vector< pair<double,double> >::iterator trit=affTriangleData.begin(); trit!=affTriangleData.end(); trit++) {
	tac << trit->first << "\t" << trit->second << std::endl;
      }
      
      tac.close();

      for(typename map<DefNode*,double>::iterator tempni=affTriangleMap.begin(); tempni!=affTriangleMap.end(); tempni++) {
	delete tempni->first;
      }
    }
    
    Vector2D gridSpace;
    gridSpace[0] = boxsize;
    gridSpace[1] = boxsize;
    AffElementGrid * affgrid = new Grid<AffinityElement,AffinityElement,2>();
    affgrid->setBox(_box);
    //nodegrid->setBox(&tmpBox);
    affgrid->setPosFunc(&AffinityElement::Centroid);
    affgrid->setGridSpace(gridSpace);
    affgrid->setComputeNeighbors(false);
    affgrid->addElems(am->getElements());
    
    gridSpace = affgrid->gridSpace();

    tvmet::Vector<int,N> nCells;
    nCells = affgrid->nBoxesDim();
    
    tvmet::Vector<int,N> mults;
    int nBoxes = affgrid->nBoxes();
    int curMult = nBoxes;
    for(int i=0; i<N; i++) {
      curMult /= nCells[i];
      mults[i] = curMult;
    }

    std::vector<double> nonaffinities(nBoxes,0.0);
    std::vector<double> affdevs(nBoxes,0.0);
    for(int nb=0; nb<nBoxes; nb++) {
      double nonaff = 0.0;
      double affdev = 0.0;
      double totArea = 0.0;
      std::set<AffinityElement *> & boxAffs = affgrid->getBoxElems(nb);
      // calculate the integral of the off-diagonal (rotational) element of u_ij-u_ji over the box (should we divide by area?)
      for(typename set<AffinityElement *>::iterator aei=boxAffs.begin(); aei!=boxAffs.end(); aei++) {
	double rot = (*aei)->Rotation();
	affdev += (rot-(shear/2.0))*((*aei)->Area());
	rot = sqr(rot-(shear/2.0));
	nonaff += rot*((*aei)->Area());
	totArea += (*aei)->Area();
      }
      if(totArea > 0.0) {
	nonaffinities[nb] = nonaff/totArea;
	affdevs[nb] = affdev/totArea;
      }
    }
    
    std::vector<double> longld(nBoxes,0.0);
    _box->setShear(0.0);
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      bool isLong = false;
      VectorND fe2e;
      fe2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
      double fillen = norm2(fe2e);
      if(fillen > maxFL) isLong = true;
      if(isLong) {
	for(int b=0; b<nNodes-1; b++) {
	  VectorND com;
	  com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	  _box->mapPoint(com);
	  tvmet::Vector<int,N> coords;
	  int idx = 0;
	  for(int i=0; i<N; i++) {
	    coords[i] = (int)(com[i]/gridSpace[i]);
	    coords[i] = coords[i]%nCells[i];
	    idx += mults[i]*coords[i];
	  }
	  VectorND e2e;
	  e2e = (*f)->nodes[b]->position() - (*f)->nodes[b+1]->position();
	  double len = norm2(e2e);
	  longld[idx] += len;
	}
      }
    }
    double boxVol = 1.0;
    for(int dim=0; dim<N; dim++) boxVol *= gridSpace[dim];
    for(int nb=0; nb<nBoxes; nb++) longld[nb] /= boxVol;
    
    std::map<DefNode*, std::pair<double,double> > data;
    std::map<DefNode*, std::pair<double,double> > dataSigned;
    for(int k=0; k<nBoxes; k++) {
      NodeBase::DofIndexMap idx(N);
      for(int j=0; j<N; j++) idx[j] = k*N + j;
      if(N==2) {
	VectorND cellCenter;
	int row = k/nCells[1];
	int column = k%nCells[1];
	cellCenter[0] = (row+0.5)*gridSpace[0];
	cellCenter[1] = (column+0.5)*gridSpace[1];
	DefNode* newNode = new BrownianNode<2>(k,idx,cellCenter,cellCenter);
	std::pair<double,double> dpr = pair<double,double>(nonaffinities[k],longld[k]);
	std::pair<double,double> dprsigned = pair<double,double>(affdevs[k],longld[k]);
	data.insert(pair<DefNode*, pair<double,double> >(newNode,dpr));
	dataSigned.insert(pair<DefNode*, pair<double,double> >(newNode,dprsigned));
      }
    }
    
    double maxdim = 0.0;
    for(int dim=0; dim<N; dim++) {
      if(gridSpace[dim] > maxdim) maxdim = gridSpace[dim];
    }
    
    std::cout << "Do you want to compute the nonaffinity-length density correlation function? ";
    int naldc;
    std::cin >> naldc;
    if(naldc==1) {
      std::cout << "Please enter a file name in which to store the data: ";
      char naldf[256];
      std::cin >> naldf;

      std::vector< std::pair<double,double> > corr = computeCrossCorrelationFunction(data,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);
      
      std::ofstream nonAffLD(naldf);
      nonAffLD << "#r\tcorr" << std::endl;
      
      for(typename vector< pair<double,double> >::iterator datait=corr.begin(); datait!=corr.end(); datait++) {
	nonAffLD << datait->first << "\t" << datait->second << std::endl;
      }
      
      nonAffLD.close();
    }

    std::cout << "Do you want to compute the nonaffinity (new measure) correlation function?\n(1) yes\n(2) no\n\n: ";
    int doAutoCorr;
    std::cin >> doAutoCorr;
    if(doAutoCorr==1) {
      std::map<DefNode *,double> autoData;
      for(typename map< DefNode*, pair<double,double> >::iterator diter=data.begin(); diter!=data.end(); diter++) {
	autoData.insert(pair<DefNode*,double>(diter->first,diter->second.first));
      }
      std::vector< std::pair<double,double> > autocorr = computeCorrelationFunction(autoData,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);
      
      std::map<DefNode *,double> autoDataSigned;
      for(typename map< DefNode*, pair<double,double> >::iterator diter=dataSigned.begin(); diter!=dataSigned.end(); diter++) {
	autoDataSigned.insert(pair<DefNode*,double>(diter->first,diter->second.first));
      }
      std::vector< std::pair<double,double> > autocorrSigned = computeCorrelationFunction(autoDataSigned,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);

      assert(autocorr.size() == autocorrSigned.size());
      int ndpts = autocorr.size();

      std::cout << "Please enter the name of a file in which to put the data: ";
      char autocorrFN[256];
      std::cin >> autocorrFN;
      
      std::ofstream ac(autocorrFN);
      ac << "#r\t\tcorrsigned\t\tcorr" << std::endl;
      
//       for(typename std::vector< pair<double,double> >::iterator datait=autocorr.begin(); datait!=autocorr.end(); datait++) {
// 	ac << datait->first << "\t\t" << datait->second << std::endl;
//       }

      for(int np=0; np<ndpts; np++) {
	ac << autocorr[np].first << "\t\t" << autocorrSigned[np].second << "\t\t" << autocorr[np].second << std::endl;
      }
      
      ac.close();
    }
    
  }
  
  template<int N>
  std::vector< std::pair<double, std::pair< double, double > > > SemiflexibleGel<N>::affineMeasurementHeadLevine(double minLength, double stepSize, double maxLength, double shear, double smallestFil, double largestFil, bool getAngularDist=false) {
    std::cout << "Beginning Head/Levine affine measurement." << std::endl;

    doublePairWErrorsContainer affdata;
    DefNodeContainer nodes4triangulation;
    // add nodes to container for triangulation //
//     Vector2D maxPos(_box->size());
//     Vector2D minPos(0.0);
//     for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
//       for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
// 	if((*dni)->position()[0] > maxPos[0]) maxPos[0] = (*dni)->position()[0];
// 	if((*dni)->position()[1] > maxPos[1]) maxPos[1] = (*dni)->position()[1];
// 	if((*dni)->position()[0] < minPos[0]) minPos[0] = (*dni)->position()[0];
// 	if((*dni)->position()[1] < minPos[1]) minPos[1] = (*dni)->position()[1];
//       }
//     }

    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itNodes = true;
      if(largestFil > 0.0 && smallestFil > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > largestFil || norm2(e2e) < smallestFil ) itNodes = false;
      } 
      if(itNodes) {
	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	  // 	if(isMaster(*dni)) {
	  // 	  Vector2D tmpPos;
	  // 	  Vector2D tmpDef;
	  // 	  tmpPos = (*dni)->position();
	  // 	  tmpDef = (*dni)->point() - (*dni)->position();
	  // 	  _box->mapPoint(tmpPos);
	  // 	  tmpDef += tmpPos;
	  // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	  // 	  newNode->setId((*dni)->id());
	  // 	  nodes4triangulation.push_back(newNode);
	  // 	}
	  if(!isSlave(*dni)) {
	    // 	  Vector2D tmpPos;
	    // 	  Vector2D tmpDef;
	    //  	  tmpPos = (*dni)->position() - minPos;
	    //  	  tmpDef = (*dni)->point() - minPos;
	    // 	  //tmpPos = (*dni)->position();
	    // 	  //_box->setShear(0.0);
	    // 	  //_box->mapPoint(tmpPos);
	    // 	  //tmpDef = (*dni)->point() - tmpPos;
	    // 	  //_box->setShear(shear);
	    // 	  //_box->mapDistance(tmpDef);
	    // 	  //tmpDef += tmpPos;
	    // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	    // 	  newNode->setId((*dni)->id());
	    nodes4triangulation.push_back(*dni);
	  }
	}
      }
    }

    // figure out how many different box sizes to use //
    //int nSteps = (int)(log2(syssize/(2.0*minLength)));
    int nSteps = (int)((maxLength-minLength)/stepSize);

    // create new grid with nodes' position (not point) as relevant location //
    Vector2D gridSpace;
    gridSpace[0] = minLength;
    gridSpace[1] = minLength;
    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    //PeriodicBox tmpBox(0.0,0.0);
    //Vector2D boxSize;
    //boxSize = maxPos - minPos;
    //if(boxSize[0] > boxSize[1]) boxSize[1] = boxSize[0];
    //else boxSize[0] = boxSize[1];
    //tmpBox.setSize(boxSize);
    nodegrid->setBox(_box);
    //nodegrid->setBox(&tmpBox);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(gridSpace);
    nodegrid->setComputeNeighbors(false);
    nodegrid->addElems(nodes4triangulation);

    char angdistfile[256];
    if(getAngularDist) {
      std::cout << "Please enter a file name in which to put the angular distribution data for each distance: ";
      std::cin >> angdistfile;
    }

    
    double oldGridSize = 0.0;
    // for each length scale, find all pairs of points in range //
    for(int j=0; j<nSteps; j++) {
      // get new grid size, reset grid spacing, and add new elements //
      //double gridSize = minLength*pow(2.0,j);
      double gridSize = minLength + j*stepSize;
      for(int i=0; i<2; i++) gridSpace[i] = gridSize;
      nodegrid->resetGridSpace(gridSpace);
      gridSpace = nodegrid->gridSpace();
      gridSize = gridSpace[0];
      if(abs(gridSize-oldGridSize) > 1.0e-6) {
	oldGridSize = gridSize;
	std::cout << "new grid size = (" << gridSpace[0] << ", " << gridSpace[1] << ")" << std::endl;
	//nodegrid->addElems(nodes4triangulation);
	// get pairs //
	int nBoxes = nodegrid->nBoxes();
	double meandev = 0.0;
	double err = 0.0;
	int nSamps = 0;
	std::vector< std::pair<double,double> > angdata;
	std::vector<int> nAngSamps;
	if(getAngularDist) {
	  angdata.clear();
	  for(int ia=0; ia<16; ia++) {
	    double centang = (ia*M_PI/16.0) + M_PI/32.0;
	    std::pair<double,double> newPair = pair<double,double>(centang,0.0);
	    angdata.push_back(newPair);
	    nAngSamps.push_back(0);
	  }
	  ofstream angdatfile(angdistfile, ios::app);
	  angdatfile << "#r = " << gridSpace[0] << std::endl;
	  angdatfile.close();
	}
	for(int k=0; k<nBoxes; k++) {
	  //std::map< DefNode*, std::set< DefNode * > > nodePairs = nodegrid->getNeighbors(k);
	  std::set< DefNode * > & boxNodes = nodegrid->getBoxElems(k);
	  DefNodeContainer neighbNodes = nodegrid->getBoxNeighbors(k);
	  for(typename std::set< DefNode * >::iterator bn=boxNodes.begin(); bn!=boxNodes.end(); bn++) {
	    //for(int nd1=0; nd1<nBoxNodes; nd1++) {
	    //for(typename std::map< DefNode *, std::set< DefNode * > >::iterator npiter=nodePairs.begin(); npiter!=nodePairs.end(); npiter++) {
	    //DefNode * node1 = npiter->first;
	    DefNode * node1 = *bn;
	    for(typename std::set< DefNode * >::iterator bn2=bn; bn2!=boxNodes.end(); bn2++) {
	      if(bn2 != bn) {
		DefNode * node2 = *bn2;
		VectorND diff;
		diff = node1->position() - node2->position();
		if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		  nSamps++;
		  double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		  VectorND finaldiff;
		  finaldiff = node1->point() - node2->point();
		  double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		  double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		  dTheta = sqr(dTheta);
		  meandev += dTheta;
		  err += sqr(dTheta);
		  if(getAngularDist) {
		    double tht = atan2(diff[1],diff[0]);
		    if(tht < 0) tht += M_PI;
		    int angindex = (int)(16.0*tht/M_PI);
		    angindex = angindex % 16;
		    nAngSamps[angindex]++;
		    angdata[angindex].second = angdata[angindex].second + dTheta;
		  }
		}
		else {
		  _box->setShear(0.0);
		  _box->mapDistance(diff);
		  if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		    nSamps++;
		    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		    VectorND finaldiff;
		    finaldiff = node1->point() - node2->point();
		    _box->setShear(shear);
		    _box->mapDistance(finaldiff);
		    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		    dTheta = sqr(dTheta);
		    meandev += dTheta;
		    err += sqr(dTheta);  
		    _box->setShear(0.0);
		    if(getAngularDist) {
		      double tht = atan2(diff[1],diff[0]);
		      if(tht < 0) tht += M_PI;
		      int angindex = (int)(16.0*tht/M_PI);
		      angindex = angindex % 16;
		      nAngSamps[angindex]++;
		      angdata[angindex].second = angdata[angindex].second + dTheta;
		    }
		  }
		}
	      }
	    }
	    int nNeighbNodes = neighbNodes.size();
	    for(int nd2=0; nd2<nNeighbNodes; nd2++) {
	      //for(typename std::set< DefNode * >::iterator partiter=npiter->second.begin(); partiter!=npiter->second.end(); partiter++) {
	      //DefNode * node2 = *partiter;
	      DefNode * node2 = neighbNodes[nd2];
	      if(node1 < node2) {
		VectorND diff;
		diff = node1->position() - node2->position();
		if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		  nSamps++;
		  double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		  VectorND finaldiff;
		  finaldiff = node1->point() - node2->point();
		  double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		  double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		  dTheta = sqr(dTheta);
		  meandev += dTheta;
		  err += sqr(dTheta);
		  if(getAngularDist) {
		    double tht = atan2(diff[1],diff[0]);
		    if(tht < 0) tht += M_PI;
		    int angindex = (int)(16.0*tht/M_PI);
		    angindex = angindex % 16;
		    nAngSamps[angindex]++;
		    angdata[angindex].second = angdata[angindex].second + dTheta;
		  }
		}
		else {
		  _box->setShear(0.0);
		  _box->mapDistance(diff);
		  if(fabs(norm2(diff)-gridSize)/gridSize < 1.0e-2) {
		    nSamps++;
		    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		    VectorND finaldiff;
		    finaldiff = node1->point() - node2->point();
		    _box->setShear(shear);
		    _box->mapDistance(finaldiff);
		    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		    dTheta = sqr(dTheta);
		    meandev += dTheta;
		    err += sqr(dTheta);  
		    _box->setShear(0.0);
		    if(getAngularDist) {
		      double tht = atan2(diff[1],diff[0]);
		      if(tht < 0) tht += M_PI;
		      int angindex = (int)(16.0*tht/M_PI);
		      angindex = angindex % 16;
		      nAngSamps[angindex]++;
		      angdata[angindex].second = angdata[angindex].second + dTheta;
		    }
		  }
		}
	      }
	    }
	  }
	}

	// compute mean and error of the mean //
	meandev /= nSamps;
	err /= nSamps;
	err = err - sqr(meandev);
	err *= (nSamps/(nSamps-1.0));
	err = sqrt(err);
	err /= sqrt(nSamps);
	meandev /= sqr(shear);
	err /= sqr(shear);
	
	// add data point to return value //
	
	std::pair<double, double> dp = pair<double,double>(meandev,err);
	doublePairWErrors newdatpt = std::pair<double, std::pair<double, double> >(gridSize,dp);
	affdata.push_back(newdatpt);
	
	if(getAngularDist) {
	  ofstream angdatfile(angdistfile, ios::app);
	  angdatfile << "#theta\tna_tot\tna_avg" << std::endl;
	  int nAngSlices = angdata.size();
	  for(int ait=0; ait<nAngSlices; ait++) {
	    angdata[ait].second = angdata[ait].second/nAngSamps[ait];
	    angdata[ait].second /= sqr(shear);
	    angdatfile << angdata[ait].first << "\t" << nAngSamps[ait]*angdata[ait].second << "\t" << angdata[ait].second << std::endl;
	  }
	  angdatfile << std::endl;
	  angdatfile.close();
	}
      }
    }
    
    return affdata;
  }
  
  template<int N>
  std::vector< std::pair<double, std::pair< double, double > > > SemiflexibleGel<N>::affineMeasurementHeadLevineInterpolated(double minLength, double stepSize, double maxLength, double shear, double largestFil) {
    std::cout << "Beginning Head/Levine affine measurement with node interpolation." << std::endl;
    
    doublePairWErrorsContainer affdata;
    FilamentContainer fils4affmeasure;
    
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itFil = true;
      if(largestFil > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > largestFil) itFil = false;
      } 
      if(itFil) fils4affmeasure.push_back(*fi);
    }
  
      
    // figure out how many different box sizes to use //
    //int nSteps = (int)(log2(syssize/(2.0*minLength)));
    int nSteps = (int)((maxLength-minLength)/stepSize);

    int nFils4measure = fils4affmeasure.size();
    

    for(int n=0; n<nSteps; n++) {
      double cursep = minLength + n*stepSize;
      double meandev = 0.0;
      std::cout << "current length scale: " << cursep << "." << std::endl;
      double err = 0.0;
      int nSamps = 0;
      for(int i=0; i<nFils4measure; i++) {
	Filament * f1 = fils4affmeasure[i];
	int nNodes1 = f1->nodes.size();
	VectorND f1e2e;
	f1e2e = f1->nodes[nNodes1-1]->position() - f1->nodes[0]->position();
	double f1len = norm2(f1e2e);
	VectorND f1com;
	f1com = .5*(f1->nodes[nNodes1-1]->position() + f1->nodes[0]->position());
	for(int j=i; j<nFils4measure; j++) {
	  Filament * f2 = fils4affmeasure[j];
	  int nNodes2 = f2->nodes.size();
	  VectorND f2e2e;
	  f2e2e = f2->nodes[nNodes2-1]->position() - f2->nodes[0]->position();
	  double f2len = norm2(f2e2e);
	  VectorND f2com;
	  f2com = .5*(f2->nodes[nNodes2-1]->position() + f2->nodes[0]->position());
	  VectorND sep;
	  sep = f1com - f2com;
	  _box->setShear(0.0);
	  _box->mapDistance(sep);
	  if(norm2(sep) <= .5*(f1len+f2len)+(1.0+1.0e-2)*cursep) {
	    if(i==j) {
	      for(int ni=0; ni<nNodes1; ni++) {
		if(!isSlave(f1->nodes[ni])) {
		  VectorND n1pos; 
		  n1pos= f1->nodes[ni]->position();
		  VectorND dfrome;
		  dfrome = n1pos - f1->nodes[0]->position();
		  double eps = (norm2(dfrome)+cursep)/f1len;
		  if(eps < 1.0) {
		    int ilow = 0;
		    int ihigh = nNodes1-1;
		    while(ihigh-ilow > 1) {
		      int icur = (ihigh+ilow)/2;
		      VectorND n2pos;
		      n2pos = f2->nodes[icur]->position();
		      VectorND nodesep;
		      nodesep = n2pos - f1->nodes[0]->position();
		      if(norm2(nodesep)/f1len < eps) ilow = icur;
		      else ihigh = icur;
		    }
		    if(!isSlave(f2->nodes[ilow]) && !isSlave(f2->nodes[ihigh])) {
		      VectorND lowend;
		      lowend = f2->nodes[ilow]->position() - f2->nodes[0]->position();
		      double loweps = norm2(lowend)/f2len;
		      double extradist = f2len*(eps-loweps);
		      VectorND seg;
		      seg = f2->nodes[ihigh]->position() - f2->nodes[ilow]->position();
		      eps = extradist/norm2(seg);
		      assert(eps <= 1.0);
		      VectorND interpoint;
		      interpoint = eps*(f2->nodes[ihigh]->position()) + (1.0-eps)*(f2->nodes[ilow]->position());
		      VectorND initsep;
		      initsep = interpoint - n1pos;
		      assert(abs(norm2(initsep)-cursep) < 1.0e-6);
		      double thetaAff = atan2(initsep[1],initsep[0]+(shear*initsep[1]));
		      VectorND finalpoint;
		      finalpoint = eps*(f2->nodes[ihigh]->point()) + (1.0-eps)*(f2->nodes[ilow]->point());
		      VectorND finalsep;
		      finalsep = finalpoint - f1->nodes[ni]->point();
		      double thetaActual = atan2(finalsep[1],finalsep[0]);
		      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		      dTheta = sqr(dTheta);
		      meandev += dTheta;
		      err += sqr(dTheta);
		      nSamps++;
		    }
		  }
		  
		}
	      }
		
	    } // end "if filaments are the same..."
	    else {
	      for(int ni=0; ni<nNodes1; ni++) {
		if(!isSlave(f1->nodes[ni])) {
		  VectorND n1pos; 
		  n1pos= f1->nodes[ni]->position();
		  VectorND a;
		  a = f2->nodes[0]->position() - n1pos;
		  _box->setShear(0.0);
		  _box->mapDistance(a);
		  double dotp = dot(f2e2e,a);
		  double inrootq = ((sqr(cursep)-sqr(norm2(a)))*sqr(f2len)) + sqr(dotp);
		  if(inrootq >= 0.0) inrootq = sqrt(inrootq);
		  double eps1 = -dotp + inrootq;
		  double eps2 = -dotp - inrootq;
		  eps1 /= sqr(f2len);
		  eps2 /= sqr(f2len);
		  int oldilow = -1;
		  if(eps1<1.0 && eps1>0.0 && inrootq>=0.0) {
		    int ilow = 0;
		    int ihigh = nNodes2-1;
		    while(ihigh-ilow > 1) {
		      int icur = (ihigh+ilow)/2;
		      VectorND n2pos;
		      n2pos = f2->nodes[icur]->position();
		      VectorND nodesep;
		      nodesep = n2pos - f2->nodes[0]->position();
		      if(norm2(nodesep)/f2len < eps1) ilow = icur;
		      else ihigh = icur;
		    }
		    assert(ilow>=0);
		    assert(ihigh<=nNodes2-1);
		    assert(ihigh-ilow==1);
		    // now compute measure with interpolated point...
		    if(!isSlave(f2->nodes[ilow]) && !isSlave(f2->nodes[ihigh])) {
		      VectorND lowend;
		      lowend = f2->nodes[ilow]->position() - f2->nodes[0]->position();
		      double loweps = norm2(lowend)/f2len;
		      double extradist = f2len*(eps1-loweps);
		      VectorND seg;
		      seg = f2->nodes[ihigh]->position() - f2->nodes[ilow]->position();
		      eps1 = extradist/norm2(seg);
		      assert(eps1 <= 1.0);
		      VectorND interpoint;
		      interpoint = eps1*(f2->nodes[ihigh]->position()) + (1.0-eps1)*(f2->nodes[ilow]->position());
		      VectorND initsep;
		      initsep = interpoint - n1pos;
		      _box->mapDistance(initsep);
		      assert(abs(norm2(initsep)-cursep) < 1.0e-6);
		      double thetaAff = atan2(initsep[1],initsep[0]+(shear*initsep[1]));
		      VectorND finalpoint;
		      finalpoint = eps1*(f2->nodes[ihigh]->point()) + (1.0-eps1)*(f2->nodes[ilow]->point());
		      VectorND finalsep;
		      finalsep = finalpoint - f1->nodes[ni]->point();
		      _box->setShear(shear);
		      _box->mapDistance(finalsep);
		      _box->setShear(0.0);
		      double thetaActual = atan2(finalsep[1],finalsep[0]);
		      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		      dTheta = sqr(dTheta);
		      meandev += dTheta;
		      err += sqr(dTheta);
		      nSamps++;
		      oldilow = ilow;
		    }
		    
		  }
		  if(eps2<1.0 && eps2>0.0 && inrootq>=0.0) {
		    int ilow = 0;
		    int ihigh = nNodes2-1;
		    while(ihigh-ilow > 1) {
		      int icur = (ihigh+ilow)/2;
		      VectorND n2pos;
		      n2pos = f2->nodes[icur]->position();
		      VectorND nodesep;
		      nodesep = n2pos - f2->nodes[0]->position();
		      if(norm2(nodesep)/f2len < eps2) ilow = icur;
		      else ihigh = icur;
		    }
		    assert(ilow>=0);
		    assert(ihigh<=nNodes2-1);
		    assert(ihigh-ilow==1);
		    // now compute measure with interpolated point...
		    if(ilow != oldilow && !isSlave(f2->nodes[ilow]) && !isSlave(f2->nodes[ihigh])) {
		      VectorND lowend;
		      lowend = f2->nodes[ilow]->position() - f2->nodes[0]->position();
		      double loweps = norm2(lowend)/f2len;
		      double extradist = f2len*(eps2-loweps);
		      VectorND seg;
		      seg = f2->nodes[ihigh]->position() - f2->nodes[ilow]->position();
		      eps2 = extradist/norm2(seg);
		      assert(eps2 <= 1.0);
		      VectorND interpoint;
		      interpoint = eps2*(f2->nodes[ihigh]->position()) + (1.0-eps2)*(f2->nodes[ilow]->position());
		      VectorND initsep;
		      initsep = interpoint - n1pos;
		      _box->mapDistance(initsep);
		      assert(abs(norm2(initsep)-cursep) < 1.0e-6);
		      double thetaAff = atan2(initsep[1],initsep[0]+(shear*initsep[1]));
		      VectorND finalpoint;
		      finalpoint = eps2*(f2->nodes[ihigh]->point()) + (1.0-eps2)*(f2->nodes[ilow]->point());
		      VectorND finalsep;
		      finalsep = finalpoint - f1->nodes[ni]->point();
		      _box->setShear(shear);
		      _box->mapDistance(finalsep);
		      _box->setShear(0.0);
		      double thetaActual = atan2(finalsep[1],finalsep[0]);
		      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		      dTheta = sqr(dTheta);
		      meandev += dTheta;
		      err += sqr(dTheta);
		      nSamps++;
		    }
		    
		  }
		}
	      }
	    } //end "if filaments are different..."
	  } // end "if filaments are close enough..."
	  
	}
      }
      // compute mean deviation and error
      meandev /= nSamps;
      err /= nSamps;
      err = err - sqr(meandev);
      err *= (nSamps/(nSamps-1.0));
      err = sqrt(err);
      err /= sqrt(nSamps);
      meandev /= sqr(shear);
      err /= sqr(shear);

      std::pair<double, double> dp = pair<double,double>(meandev,err);
      doublePairWErrors newdatpt = std::pair<double, std::pair<double, double> >(cursep,dp);
      affdata.push_back(newdatpt);
    }

    return affdata;
  }
  
  template<int N>
  void SemiflexibleGel<N>::affineBoxesMeasurement(VectorND & boxsize, double pairDist, double shear, double largestFil, std::string fileName, bool doCorrTest) {
    DefNodeContainer nodes4triangulation;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itNodes = true;
      if(largestFil > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > largestFil) itNodes = false;
      } 
      if(itNodes) {
	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	  // 	if(isMaster(*dni)) {
	  // 	  Vector2D tmpPos;
	  // 	  Vector2D tmpDef;
	  // 	  tmpPos = (*dni)->position();
	  // 	  tmpDef = (*dni)->point() - (*dni)->position();
	  // 	  _box->mapPoint(tmpPos);
	  // 	  tmpDef += tmpPos;
	  // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	  // 	  newNode->setId((*dni)->id());
	  // 	  nodes4triangulation.push_back(newNode);
	  // 	}
	  if(!isSlave(*dni)) {
	    // 	  Vector2D tmpPos;
	    // 	  Vector2D tmpDef;
	    //  	  tmpPos = (*dni)->position() - minPos;
	    //  	  tmpDef = (*dni)->point() - minPos;
	    // 	  //tmpPos = (*dni)->position();
	    // 	  //_box->setShear(0.0);
	    // 	  //_box->mapPoint(tmpPos);
	    // 	  //tmpDef = (*dni)->point() - tmpPos;
	    // 	  //_box->setShear(shear);
	    // 	  //_box->mapDistance(tmpDef);
	    // 	  //tmpDef += tmpPos;
	    // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	    // 	  newNode->setId((*dni)->id());
	    nodes4triangulation.push_back(*dni);
	  }
	}
      }
    }

    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(boxsize);
    nodegrid->setComputeNeighbors(false);
    nodegrid->addElems(nodes4triangulation);

    VectorND actualGridSize;
    actualGridSize = nodegrid->gridSpace();

    std::cout << "Do you want to store the nonaffinities of all collected point pairs (1 for yes)? ";
    int collectPairs;
    std::cin >> collectPairs;
    
    int nBoxes = nodegrid->nBoxes();
    std::vector<double> affMeasures(nBoxes);
    std::vector<double> nonaffs;
    std::cout << "Computing affinity measure in " << nBoxes << " boxes." << std::endl;
    for(int k=0; k<nBoxes; k++) {
      if(k%10 == 0) std::cout << "Finished " << k << " boxes." << std::endl;
      affMeasures[k] = 0.0;
      double nSamps = 0.0;
      //std::map< DefNode*, std::set< DefNode * > > nodePairs = nodegrid->getNeighbors(k);
      std::set< DefNode * > & boxNodes = nodegrid->getBoxElems(k);
      DefNodeContainer neighbNodes = nodegrid->getBoxNeighbors(k);
      for(typename std::set< DefNode * >::iterator bn=boxNodes.begin(); bn!=boxNodes.end(); bn++) {
	//for(int nd1=0; nd1<nBoxNodes; nd1++) {
	//for(typename std::map< DefNode *, std::set< DefNode * > >::iterator npiter=nodePairs.begin(); npiter!=nodePairs.end(); npiter++) {
	//DefNode * node1 = npiter->first;
	DefNode * node1 = *bn;
	for(typename std::set< DefNode * >::iterator bn2=bn; bn2!=boxNodes.end(); bn2++) {
	  if(bn2 != bn) {
	    DefNode * node2 = *bn2;
	    VectorND diff;
	    diff = node1->position() - node2->position();
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 1.0;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      affMeasures[k] += dTheta;
	      if(collectPairs==1) nonaffs.push_back(dTheta/sqr(shear));
	    }
	    else {
	      _box->setShear(0.0);
	      _box->mapDistance(diff);
	      if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
		nSamps += 1.0;
		double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		VectorND finaldiff;
		finaldiff = node1->point() - node2->point();
		_box->setShear(shear);
		_box->mapDistance(finaldiff);
		double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		dTheta = sqr(dTheta);
		affMeasures[k] += dTheta;
		if(collectPairs==1) nonaffs.push_back(dTheta/sqr(shear));
		_box->setShear(0.0);
	      }
	    }
	  }
	}
	int nNeighbNodes = neighbNodes.size();
	for(int nd2=0; nd2<nNeighbNodes; nd2++) {
	  //for(typename std::set< DefNode * >::iterator partiter=npiter->second.begin(); partiter!=npiter->second.end(); partiter++) {
	  //DefNode * node2 = *partiter;
	  DefNode * node2 = neighbNodes[nd2];
	  VectorND diff;
	  diff = node1->position() - node2->position();
	  if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	    nSamps += 0.5;
	    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	    VectorND finaldiff;
	    finaldiff = node1->point() - node2->point();
	    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	    dTheta = sqr(dTheta);
	    affMeasures[k] += 0.5*dTheta;
	    if(collectPairs==1 && node1>node2) nonaffs.push_back(dTheta/sqr(shear));
	  }
	  else {
	    _box->setShear(0.0);
	    _box->mapDistance(diff);
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 0.5;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      _box->setShear(shear);
	      _box->mapDistance(finaldiff);
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      affMeasures[k] += 0.5*dTheta;
	      if(collectPairs==1 && node1>node2) nonaffs.push_back(dTheta/sqr(shear));
	      _box->setShear(0.0);
	    }
	  }
	  
	}
      }
      
      if(nSamps > 0.0) {
	affMeasures[k] /= nSamps;
	affMeasures[k] /= sqr(shear);
      }
      else affMeasures[k] = 0.0;
    }

    if(collectPairs!=1) {
    // print out average value of nonaffinity and standard deviation
    
      double meanna = 0.0;
      double stdna = 0.0;
      for(int nk=0; nk<nBoxes; nk++) {
	meanna += affMeasures[nk];
	stdna += sqr(affMeasures[nk]);
      }
      meanna /= nBoxes;
      stdna /= nBoxes;
      stdna -= sqr(meanna);
      stdna = sqrt(stdna);
      
      meanna /= sqr(shear);
      stdna /= sqr(shear);
      
      std::cout << "Average value of nonaffinity = " << meanna << "; standard deviation = " << stdna << "." << std::endl;
    }

    else {
      std::cout << "Enter the name of a file in which to put the nonaffinities: ";
      char naf[256];
      std::cin >> naf;
      std::ofstream naffile(naf);
      naffile << "#nonaffinities, r = " << pairDist << std::endl;
      for(vector<double>::iterator pdi=nonaffs.begin(); pdi!=nonaffs.end(); pdi++) {
	naffile << *pdi << std::endl;
      }
      naffile.close();
    }

    // now write vtk file with rectangles containing one scalar--the nonaffinity measure

    std::string fName = fileName + ".vtk";
    std::ofstream ofs(fName.c_str());
    if (!ofs) {
      std::cout << "Error: can not open paraview output file "
		<< fName
		<< std::endl;
      return;
    }

    tvmet::Vector<int,N> nBoxesDim;
    nBoxesDim = nodegrid->nBoxesDim();
    int nBTest = 1;
    for(int n=0; n<N; n++) {
      nBTest *= nBoxesDim[n];
    }
    assert(nBoxes == nBTest);

    int nPts = 1;
    for(int n=0; n<N; n++) {
      nPts *= (nBoxesDim[n]+1);
    }
    
    ofs << "# vtk DataFile Version 2.0\n"
	<< "Test example" << std::endl
	<< "ASCII" << std::endl
	<< "DATASET POLYDATA" << std::endl
	<< "POINTS  " << nPts << "  double" << std::endl;
    
    if(N==2) {
      for(int p=0; p<=nBoxesDim[0]; p++) {
	for(int q=0; q<=nBoxesDim[1]; q++) {
	  ofs << std::setprecision(16) 
	      << p*actualGridSize[0] << "  "
	      << 0.0 << "  "
	      << q*actualGridSize[1] << std::endl;
	}
      }

      ofs << "POLYGONS  " << nBoxes << "  "
	  << 5*nBoxes << std::endl;
      
      for(int p=0; p<nBoxesDim[0]; p++) {
	for(int q=0; q<nBoxesDim[1]; q++) {
	  int lowerCorner = p*(nBoxesDim[1]+1) + q;
	  ofs << 4 << "  "
	      << std::setw(10) << lowerCorner
	      << std::setw(10) << lowerCorner+1
	      << std::setw(10) << lowerCorner+nBoxesDim[1]+2
	      << std::setw(10) << lowerCorner+nBoxesDim[1]+1
	      << std::endl;
	}
      }
      
      ofs << "CELL_DATA    " << nBoxes << std::endl;
      ofs << "SCALARS    Nonaffinity    double    1" << std::endl;
      ofs << "LOOKUP_TABLE default" << std::endl;
      for(int p=0; p<nBoxes; p++) ofs << affMeasures[p] << std::endl;
      
    }
    
    ofs.close();

    if(doCorrTest) {
      
      //Mo
      std::cout << "Do you want to compute the nonaffinity-nonaffinity correlation function?\n(1) yes\n(2) no\n:";
      int nanacorr;
      std::cin >> nanacorr;

      std::cout << "Do you also want to compute the long filament length density/Head-Levine nonaffinity correlation function?\n(1) yes\n(2) no\n:";
      int ldnacorr;
      std::cin >> ldnacorr;
      std::vector<double> longld(nBoxes,0.0);
      double maxdist;
      if(ldnacorr==1) {
	std::cout << "Please input a maximum distance on which to compute correlations: ";
	std::cin >> maxdist;
	_box->setShear(0.0);
	for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
	  int nNodes = (*f)->nodes.size();
	  bool isLong = false;
	  VectorND fe2e;
	  fe2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
	  double fillen = norm2(fe2e);
	  if(fillen > largestFil) isLong = true;
	  if(isLong) {
	    for(int b=0; b<nNodes-1; b++) {
	      VectorND com;
	      com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	      _box->mapPoint(com);
	      tvmet::Vector<int,N> coords;
	      int idx = 0;
	      for(int i=0; i<N; i++) {
		coords[i] = (int)(com[i]/actualGridSize[i]);
		coords[i] = coords[i]%nBoxesDim[i];
	      }
	      if(N==2) idx = nBoxesDim[1]*coords[0] + coords[1];
	      VectorND e2e;
	      e2e = (*f)->nodes[b]->position() - (*f)->nodes[b+1]->position();
	      double len = norm2(e2e);
	      longld[idx] += len;
	    }
	  }
	}
	double boxVol = 1.0;
	for(int dim=0; dim<N; dim++) boxVol *= actualGridSize[dim];
	for(int nb=0; nb<nBoxes; nb++) longld[nb] /= boxVol;
      }
 
      std::map<DefNode*,double> dataPts;
      std::map< DefNode*, std::pair<double,double> > lendensNonaffData;
      for(int k=0; k<nBoxes; k++) {
	if(affMeasures[k] > 0.0) {
	  NodeBase::DofIndexMap idx(N);
	  for(int j=0; j<N; j++) idx[j] = k*N + j;
	  if(N==2) {
	    VectorND cellCenter;
	    int row = k/nBoxesDim[1];
	    int column = k%nBoxesDim[1];
	    cellCenter[0] = (row+0.5)*actualGridSize[0];
	    cellCenter[1] = (column+0.5)*actualGridSize[1];
	    DefNode* newNode = new BrownianNode<2>(k,idx,cellCenter,cellCenter);
	    dataPts.insert(pair<DefNode*,double>(newNode,affMeasures[k]));
	    if(ldnacorr==1) {
	      std::pair<double,double> newPair = pair<double,double>(affMeasures[k],longld[k]);
	      lendensNonaffData.insert(pair< DefNode*, pair<double,double> >(newNode,newPair));
	    }
	  }
	}
      }
      if(N==2) {
	if(nanacorr==1) {
	  std::vector< pair<double,double> > corrData = computeCorrelationFunction(dataPts,max(actualGridSize[0],actualGridSize[1]),min(_box->size()[0],_box->size()[1])/3.0,max(actualGridSize[0],actualGridSize[1]),min(actualGridSize[0],actualGridSize[1])/2.0);
	  std::cout << "Please input a file name in which to output the nonaffinity correlation data: ";
	  char affCorrFN[256];
	  std::cin >> affCorrFN;
	  std::ofstream affCorrFile(affCorrFN);
	  affCorrFile << "#r\tcorr\n";
	  for(typename vector< pair<double,double> >::iterator pi=corrData.begin(); pi!=corrData.end(); pi++) {
	    affCorrFile << pi->first << "\t" << pi->second << "\n";
	  }
	  affCorrFile.close();
	}
	
	if(ldnacorr==1) {
	  std::cout << "Please enter a file name in which to store the long filament lengt density/Head-Levine nonaffinity correlaion data: ";
	  char naldf[256];
	  std::cin >> naldf;
	  
	  double maxdim = max(actualGridSize[0],actualGridSize[1]);
	  //double maxdist = min(_box->size()[0],_box->size()[1])/3.0;
	  std::vector< std::pair<double,double> > corr = computeCrossCorrelationFunction(lendensNonaffData,2.0*maxdim,maxdist,2.0*maxdim,maxdim/2.0);
	  
	  std::ofstream nonAffLD(naldf);
	  nonAffLD << "#r\tcorr" << std::endl;
	  
	  for(typename vector< pair<double,double> >::iterator datait=corr.begin(); datait!=corr.end(); datait++) {
	    nonAffLD << datait->first << "\t" << datait->second << std::endl;
	  }
	  
	  nonAffLD.close();
	}
      }
  
    }
  }

  template<int N>
  std::vector< std::pair<double,double> > SemiflexibleGel<N>::computeNemCorrelations(double minSep, double step, double tol) {
    double maxSep = .25*(_box->size()[0] + _box->size()[1]);
    int nSteps = (int)((maxSep-minSep)/step) - 1;
    std::vector< std::pair<double,double> > corrData;
    
    VectorND curGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = minSep;
    Grid<Filament,Filament,2> * grid = new Grid<Filament,Filament,2>(_box,curGridSize,&Filament::point,false);
    curGridSize = grid->gridSpace();

    double corrval = 1.0;
//     for(typename map<DefNode*,double>::iterator mi=dataPts.begin(); mi!=dataPts.end(); mi++) {
//       meanval += mi->second;
//       corrval += sqr(mi->second);
//       nodegrid->addElem(mi->first);
//     }
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      grid->addElem(*fi);
    }
    int nFils =_filaments.size();

    pair<double,double> corrPt = pair<double,double>(0.0,corrval);
    corrData.push_back(corrPt);
    
    for(int ns=0; ns<nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      VectorND oldGridSize;
      oldGridSize = curGridSize;
      double curdist = minSep + ns*step;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + tol;
      grid->resetGridSpace(curGridSize);
      curGridSize = grid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + tol);
      int nGridBoxes = grid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< Filament*, std::set<Filament*> > pairs = grid->getNeighbors(nb);
	for(typename map< Filament*, set<Filament*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  Filament* node1 = pairit->first;
	  for(typename set<Filament*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    Filament* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->point() - node2->point();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < tol) {
		nSamps++;
		VectorND e2e1;
		e2e1 = node1->nodes[0]->point() - node1->nodes[node1->nodes.size()-1]->point();
		double len1 = norm2(e2e1);
		e2e1 /= len1;
		VectorND e2e2;
		e2e2 = node2->nodes[0]->point() - node2->nodes[node2->nodes.size()-1]->point();
		double len2 = norm2(e2e2);
		e2e2 /= len2;
		corrval += 2.0*sqr(dot(e2e1,e2e2)) - 1.0;
	      }
	    }
	  }
	}
      }
      if(nSamps > 0) {
	corrval /= nSamps;
	std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
	corrData.push_back(curPair);
      }
    }
    
    delete grid;

    return corrData;
  }

  template<int N>
  std::vector< std::pair<double,double> > SemiflexibleGel<N>::computeCorrelationFunction(std::map<BrownianNode<N> *, double> & dataPts, double minSep, double maxSep, double step, double tol) {
    int nSteps = (int)((maxSep-minSep)/step);
    std::vector< std::pair<double,double> > corrData;
    
    VectorND curGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = minSep;
    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(curGridSize);
    nodegrid->setComputeNeighbors(false);
    curGridSize = nodegrid->gridSpace();

    double meanval = 0.0;
    double corrval = 0.0;
    for(typename map<DefNode*,double>::iterator mi=dataPts.begin(); mi!=dataPts.end(); mi++) {
      meanval += mi->second;
      corrval += sqr(mi->second);
      nodegrid->addElem(mi->first);
    }
    meanval /= dataPts.size();
    corrval /= dataPts.size();
    corrval -= sqr(meanval);
    pair<double,double> corrPt = pair<double,double>(0.0,corrval);
    corrData.push_back(corrPt);
    
    for(int ns=0; ns<nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      VectorND oldGridSize;
      oldGridSize = curGridSize;
      double curdist = minSep + ns*step;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + tol;
      nodegrid->resetGridSpace(curGridSize);
      curGridSize = nodegrid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + tol);
      int nGridBoxes = nodegrid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< DefNode*, std::set<DefNode*> > pairs = nodegrid->getNeighbors(nb);
	for(typename map< DefNode*, set<DefNode*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  DefNode* node1 = pairit->first;
	  for(typename set<DefNode*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    DefNode* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->position() - node2->position();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < tol) {
		nSamps++;
		corrval += (dataPts[node1]-meanval)*(dataPts[node2]-meanval);
	      }
	    }
	  }
	}
      }
      corrval /= nSamps;
      std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
      corrData.push_back(curPair);
    }
    
    delete nodegrid;

    return corrData;
  }

  template<int N>
  std::vector< std::pair<double,double> > SemiflexibleGel<N>::computeCrossCorrelationFunction(std::map< BrownianNode<N> *, std::pair<double,double> > & dataPts, double minSep, double maxSep, double step, double tol) {
    int nSteps = (int)((maxSep-minSep)/step);
    std::vector< std::pair<double,double> > corrData;
    
    VectorND curGridSize;
    for(int k=0; k<N; k++) curGridSize[k] = minSep;
    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(curGridSize);
    nodegrid->setComputeNeighbors(false);
    curGridSize = nodegrid->gridSpace();

    double meanval1 = 0.0;
    double meanval2 = 0.0;
    double corrval = 0.0;
    for(typename map< DefNode*,pair<double,double> >::iterator mi=dataPts.begin(); mi!=dataPts.end(); mi++) {
      meanval1 += mi->second.first;
      meanval2 += mi->second.second;
      corrval += ((mi->second.first)*(mi->second.second));
      nodegrid->addElem(mi->first);
    }
    meanval1 /= dataPts.size();
    meanval2 /= dataPts.size();
    corrval /= dataPts.size();
    corrval -= (meanval1*meanval2);
    pair<double,double> corrPt = pair<double,double>(0.0,corrval);
    corrData.push_back(corrPt);
    
    for(int ns=0; ns<nSteps; ns++) {
      int nSamps = 0;
      corrval = 0.0;
      VectorND oldGridSize;
      oldGridSize = curGridSize;
      double curdist = minSep + ns*step;
      for(int k=0; k<N; k++) curGridSize[k] = curdist + tol;
      nodegrid->resetGridSpace(curGridSize);
      curGridSize = nodegrid->gridSpace();
      std::cout << "Current desired node separation = " << curdist << "; current grid size = (" << curGridSize[0] << ", " << curGridSize[1] << ")." << std::endl;
      assert(min(curGridSize[0],curGridSize[1]) >= curdist + tol);
      int nGridBoxes = nodegrid->nBoxes();
      for(int nb=0; nb<nGridBoxes; nb++) {
	std::map< DefNode*, std::set<DefNode*> > pairs = nodegrid->getNeighbors(nb);
	for(typename map< DefNode*, set<DefNode*> >::iterator pairit=pairs.begin(); pairit!=pairs.end(); pairit++) {
	  DefNode* node1 = pairit->first;
	  for(typename set<DefNode*>::iterator partit=pairit->second.begin(); partit!=pairit->second.end(); partit++) {
	    DefNode* node2 = *partit;
	    if(node1<node2) {
	      VectorND sep;
	      sep = node1->position() - node2->position();
	      _box->mapDistance(sep);
	      if(fabs(norm2(sep)-curdist) < tol) {
		nSamps++;
		corrval += (dataPts[node1].first-meanval1)*(dataPts[node2].second-meanval2);
	      }
	    }
	  }
	}
      }
      corrval /= nSamps;
      std::pair<double,double> curPair = pair<double,double>(curdist,corrval);
      corrData.push_back(curPair);
    }
    
    delete nodegrid;

    return corrData;
  }

  template<int N>
  double SemiflexibleGel<N>::computeCorrelation(std::vector<double> & dat1, std::vector<double> & dat2) {
    assert(dat1.size() == dat2.size());
    int nPts = dat1.size();
    double mn1 = 0.0;
    double mn2 = 0.0;
    double std1 = 0.0;
    double std2 = 0.0;
    double corr = 0.0;

    for(int i=0; i<nPts; i++) {
      mn1 += dat1[i];
      mn2 += dat2[i];
      std1 += sqr(dat1[i]);
      std2 += sqr(dat2[i]);
      corr += dat1[i]*dat2[i];
    }

    mn1 /= nPts;
    mn2 /= nPts;
    std1 /= nPts;
    std2 /= nPts;
    std1 -= sqr(mn1);
    std2 -= sqr(mn2);
    std1 *= nPts/(nPts-1.0);
    std2 *= nPts/(nPts-1.0);
    std1 = sqrt(std1);
    std2 = sqrt(std2);
    corr /= nPts;
    corr -= mn1*mn2;
    corr /= (std1*std2);
    corr *= nPts/(nPts-1.0);

    return corr;
  }

  template<int N>
  void SemiflexibleGel<N>::computeCrossCorrelations(double len, double shear, std::string & fileName) {
    std::vector<double> nonaffinities;

    VectorND boxsize;
    for(int i=0; i<N; i++) boxsize[i] = len;

    std::cout << "Enter the maximum filament length from which to take nodes for the affinity measure: ";
    double maxFL;
    std::cin >> maxFL;

    std::cout << "Enter a pair distance to use for computing nonaffinity: ";
    double pairDist;
    std::cin >> pairDist;
    assert(pairDist < len);
    assert(pairDist > 0.0);
    
    DefNodeContainer nodes4triangulation;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      bool itNodes = true;
      if(maxFL > 0.0) {
	int nNds = (*fi)->nodes.size();
	VectorND e2e;
	e2e = (*fi)->nodes[nNds-1]->position() - (*fi)->nodes[0]->position();
	if(norm2(e2e) > maxFL) itNodes = false;
      } 
      if(itNodes) {
	for(DefNodeIterator dni=(*fi)->nodes.begin(); dni!=(*fi)->nodes.end(); dni++) {
	  // 	if(isMaster(*dni)) {
	  // 	  Vector2D tmpPos;
	  // 	  Vector2D tmpDef;
	  // 	  tmpPos = (*dni)->position();
	  // 	  tmpDef = (*dni)->point() - (*dni)->position();
	  // 	  _box->mapPoint(tmpPos);
	  // 	  tmpDef += tmpPos;
	  // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	  // 	  newNode->setId((*dni)->id());
	  // 	  nodes4triangulation.push_back(newNode);
	  // 	}
	  if(!isSlave(*dni)) {
	    // 	  Vector2D tmpPos;
	    // 	  Vector2D tmpDef;
	    //  	  tmpPos = (*dni)->position() - minPos;
	    //  	  tmpDef = (*dni)->point() - minPos;
	    // 	  //tmpPos = (*dni)->position();
	    // 	  //_box->setShear(0.0);
	    // 	  //_box->mapPoint(tmpPos);
	    // 	  //tmpDef = (*dni)->point() - tmpPos;
	    // 	  //_box->setShear(shear);
	    // 	  //_box->mapDistance(tmpDef);
	    // 	  //tmpDef += tmpPos;
	    // 	  DefNode* newNode = new BrownianNode<2>((*dni)->id(),(*dni)->index(),tmpPos,tmpDef);
	    // 	  newNode->setId((*dni)->id());
	    nodes4triangulation.push_back(*dni);
	  }
	}
      }
    }

    NodeGrid* nodegrid = new Grid<DefNode,BaseDefNode,2>();
    nodegrid->setBox(_box);
    nodegrid->setPosFunc(&DeformationNode<2>::position);
    nodegrid->setGridSpace(boxsize);
    nodegrid->setComputeNeighbors(false);
    nodegrid->addElems(nodes4triangulation);

    boxsize = nodegrid->gridSpace();
    
    int nBoxes = nodegrid->nBoxes();
    for(int k=0; k<nBoxes; k++) {
      double nSamps = 0.0;
      nonaffinities.push_back(0.0);
      //std::map< DefNode*, std::set< DefNode * > > nodePairs = nodegrid->getNeighbors(k);
      std::set< DefNode * > & boxNodes = nodegrid->getBoxElems(k);
      DefNodeContainer neighbNodes = nodegrid->getBoxNeighbors(k);
      for(typename std::set< DefNode * >::iterator bn=boxNodes.begin(); bn!=boxNodes.end(); bn++) {
	//for(int nd1=0; nd1<nBoxNodes; nd1++) {
	//for(typename std::map< DefNode *, std::set< DefNode * > >::iterator npiter=nodePairs.begin(); npiter!=nodePairs.end(); npiter++) {
	//DefNode * node1 = npiter->first;
	DefNode * node1 = *bn;
	for(typename std::set< DefNode * >::iterator bn2=bn; bn2!=boxNodes.end(); bn2++) {
	  if(bn2 != bn) {
	    DefNode * node2 = *bn2;
	    VectorND diff;
	    diff = node1->position() - node2->position();
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 1.0;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      nonaffinities[k] += dTheta;
	    }
	    else {
	      _box->setShear(0.0);
	      _box->mapDistance(diff);
	      if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
		nSamps += 1.0;
		double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
		VectorND finaldiff;
		finaldiff = node1->point() - node2->point();
		_box->setShear(shear);
		_box->mapDistance(finaldiff);
		double thetaActual = atan2(finaldiff[1],finaldiff[0]);
		double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
		dTheta = sqr(dTheta);
		nonaffinities[k] += dTheta;
		_box->setShear(0.0);
	      }
	    }
	  }
	}
	int nNeighbNodes = neighbNodes.size();
	for(int nd2=0; nd2<nNeighbNodes; nd2++) {
	  //for(typename std::set< DefNode * >::iterator partiter=npiter->second.begin(); partiter!=npiter->second.end(); partiter++) {
	  //DefNode * node2 = *partiter;
	  DefNode * node2 = neighbNodes[nd2];
	  VectorND diff;
	  diff = node1->position() - node2->position();
	  if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	    nSamps += 0.5;
	    double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	    VectorND finaldiff;
	    finaldiff = node1->point() - node2->point();
	    double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	    double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	    dTheta = sqr(dTheta);
	    nonaffinities[k] += 0.5*dTheta;
	  }
	  else {
	    _box->setShear(0.0);
	    _box->mapDistance(diff);
	    if(fabs(norm2(diff)-pairDist)/pairDist < 1.0e-2) {
	      nSamps += 0.5;
	      double thetaAff = atan2(diff[1],diff[0]+(shear*diff[1]));
	      VectorND finaldiff;
	      finaldiff = node1->point() - node2->point();
	      _box->setShear(shear);
	      _box->mapDistance(finaldiff);
	      double thetaActual = atan2(finaldiff[1],finaldiff[0]);
	      double dTheta = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	      dTheta = sqr(dTheta);
	      nonaffinities[k] += 0.5*dTheta;  
	      _box->setShear(0.0);
	    }
	  }
	  
	}
      }
      
      if(nSamps > 0.0) {
	nonaffinities[k] /= nSamps;
	nonaffinities[k] /= sqr(shear);
      }
      else nonaffinities[k] = 0.0;
    }


    tvmet::Vector<int,N> nCells;
    nCells = nodegrid->nBoxesDim();
    
    tvmet::Vector<int,N> mults;
    int curMult = nBoxes;
    for(int i=0; i<N; i++) {
      curMult /= nCells[i];
      mults[i] = curMult;
    }


    std::vector<double> energies(nBoxes,0.0);
    std::vector<double> bendenergies(nBoxes,0.0);
    std::vector<double> stretchenergies(nBoxes,0.0);
    std::vector<double> lengthdensity(nBoxes,0.0);
    std::vector<double> longfillengthdensity(nBoxes,0.0);    
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      int nNodes = (*f)->nodes.size();
      bool isLong = false;
      VectorND fe2e;
      fe2e = (*f)->nodes[nNodes-1]->position() - (*f)->nodes[0]->position();
      double fillen = norm2(fe2e);
      if(fillen > maxFL) isLong = true;
      for(int b=0; b<nNodes-1; b++) {
	VectorND com;
	com = .5*((*f)->nodes[b]->position() + (*f)->nodes[b+1]->position());
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
// 	std::cout << "Troubleshoot: coords = (" 
// 		  << coords[0] << ", " << coords[1] << "); index = " 
// 		  << idx << "; grid dimensions = ("
// 		  << nCells[0] << ", " << nCells[1] << ")."
// 		  << std::endl;
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->bonds[b]->energy();
	stretchenergies[idx] += (*f)->bonds[b]->energy();
	VectorND e2e;
	e2e = (*f)->nodes[b]->position() - (*f)->nodes[b+1]->position();
	double len = norm2(e2e);
	lengthdensity[idx] += len;
	if(isLong) longfillengthdensity[idx] += len;
      }
      for(int a=1; a<nNodes-1; a++) {
	VectorND com;
	com = (*f)->nodes[a]->position();
	_box->mapPoint(com);
	tvmet::Vector<int,N> coords;
	int idx = 0;
	for(int i=0; i<N; i++) {
	  coords[i] = (int)(com[i]/boxsize[i]);
	  coords[i] = coords[i]%nCells[i];
	  idx += mults[i]*coords[i];
	}
	assert(idx < nBoxes);
	assert(idx >= 0);
	energies[idx] += (*f)->angles[a-1]->energy();
	bendenergies[idx] += (*f)->angles[a-1]->energy();
      }
    }
    
    double boxVol = 1.0;
    for(int nd=0; nd<N; nd++) boxVol *= boxsize[nd];
    for(int ni=0; ni<nBoxes; ni++) {
      lengthdensity[ni] /= boxVol;
      longfillengthdensity[ni] /= boxVol;
    }
    
    double endenscorr = computeCorrelation(energies,lengthdensity);
    double bendendenscorr = computeCorrelation(bendenergies,lengthdensity);
    double stretchendenscorr = computeCorrelation(stretchenergies,lengthdensity);
    double affdenscorr = computeCorrelation(nonaffinities,lengthdensity);
    double affldenscorr = computeCorrelation(nonaffinities,longfillengthdensity);
    double affbendencorr = computeCorrelation(nonaffinities,bendenergies);
    
    std::ofstream corrFile(fileName.c_str());

    corrFile << "#Box Size = (" << boxsize[0] << ", " << boxsize[1] << ")" << std::endl 
	     << "#Pair Separation = " << pairDist << std::endl << std::endl;

    corrFile << "#Energy-Length Density\n" << endenscorr << std::endl << std::endl
	     << "#Bending Energy-Length Density\n" << bendendenscorr << std::endl << std::endl
	     << "#Stretcing Energy-Length Density\n" << stretchendenscorr << std::endl << std::endl
	     << "#Nonaffinity-Length Density\n" << affdenscorr << std::endl << std::endl
	     << "#Nonaffinity-Long Filament Length Density\n" << affldenscorr << std::endl << std::endl
	     << "#Nonaffinity-Bending Energy\n" << affbendencorr << std::endl;
    
    corrFile.close();
    
    delete nodegrid;
    
  }

  template<int N>
  void SemiflexibleGel<N>::checkParallelForces() {
    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      DefNode* n1 = (*f)->nodes[0];
      DefNode* n2 = (*f)->nodes[(*f)->nodes.size()-1];
      const VectorND & p1 = n1->point();
      const VectorND & p2 = n2->point();
      const VectorND & force1 = n1->force();
      const VectorND & force2 = n2->force();
      VectorND diff;
      diff = p2 - p1;
      double f1parallel = dot(diff,force1);
      double f2parallel = dot(diff,force2);
      if(abs(f1parallel-f2parallel)/(abs(f1parallel)+abs(f2parallel)) > 1.0e-6) {
	std::cerr << "Error: parallel forces on rod ends are unequal." << std::endl
		  << "F_par on end 1 = " << f1parallel << std::endl
		  << "F_par on end 2 = " << f2parallel << std::endl << std::endl;
      }
    }
  }

  template<int N>
  void SemiflexibleGel<N>::printCLFilDist() {
    std::map<int,int> CLFilDist;
    typename std::map<DefNode*,int>::iterator cli = _nSlavesMap.begin();
    for(cli; cli!=_nSlavesMap.end(); cli++) {
      int nFilsCL = cli->second + 1;
      if(CLFilDist.find(nFilsCL) == CLFilDist.end()) CLFilDist.insert(pair<int,int>(nFilsCL,1));
      else CLFilDist[nFilsCL]++;
    }
    std::cout << std::endl << "Printing out distribution of # of filaments in crosslinks." << std::endl << std::endl;
    std::cout << "# of fils\t# of cls" << std::endl;
    for(typename map<int,int>::iterator clfdi = CLFilDist.begin(); clfdi!=CLFilDist.end(); clfdi++) {
      std::cout << clfdi->first << "\t" << clfdi->second << std::endl;
    }
    std::cout << std::endl;
  }

  template<int N>
  void SemiflexibleGel<N>::printInitialBends() {
    double meanAng = 0.0;
    double stdd = 0.0;
    int nAngs = 0;
    std::multiset<double> angs;
    double mina = M_PI;
    double maxa = -M_PI;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(AngleIterator ai=(*fi)->angles.begin(); ai!=(*fi)->angles.end(); ai++) {
        double angABC = (*ai)->getAngleABC();
	meanAng += angABC;
	stdd += sqr(angABC);
	nAngs++;
	angs.insert(angABC);
	if(angABC < mina) mina = angABC;
	if(angABC > maxa) maxa = angABC;
      }
    }
    meanAng /= nAngs;
    stdd /= nAngs;
    stdd -= sqr(meanAng);
    stdd = sqrt(stdd);

    double binwidth = 3.49*stdd/pow(nAngs,1.0/3.0);
    int nBins = (int)(floor((maxa-mina)/binwidth)+.5);
    binwidth = (maxa-mina)/nBins;
    double minVal = mina;
    std::cout << "Printing distribution of initial bending angles." << std::endl << std::endl;
    std::cout << "theta\t#angles" << std::endl;
    for(int i=0; i<nBins; i++) {
      multiset<double>::iterator lenItHigh;
      double curHigh = minVal + (i+1.0)*binwidth;
      lenItHigh = angs.lower_bound(curHigh);
      int numPts = angs.size();
      angs.erase(angs.begin(),lenItHigh);
      std::cout << curHigh - 0.5*binwidth << "\t" << numPts-angs.size() << std::endl;
    }
  }

  template<int N>
  void SemiflexibleGel<N>::printBigBends() {
    int nLargeAngles = 0;
    for(FilamentIterator fi=_filaments.begin(); fi!=_filaments.end(); fi++) {
      for(AngleIterator ai=(*fi)->angles.begin(); ai!=(*fi)->angles.end(); ai++) {
        double angABC = (*ai)->getAngleABC();
	if(abs(angABC) > M_PI/2.0) nLargeAngles++;
      }
    }
    std::cout << nLargeAngles << " large angles detected." << std::endl;
  }

  template<int N>
  double SemiflexibleGel<N>::computeBucklingEnergy(double shear, double kap, double mu) {
    int nFils = _filaments.size();
    double en2return = 0.0;
    double lB = sqrt(kap/mu);
    double crit = sqr(M_PI)*sqr(lB)/shear;
    for(int i=0; i<nFils; i++) {
      Filament* f = filament(i);
      int nNodes = f->nodes.size();
      VectorND e2e;
      e2e = f->nodes[0]->position() - f->nodes[nNodes-1]->position();
      double ang = atan2(e2e[1],e2e[0]);
      double cossin = cos(ang)*sin(ang);
      double curLen = 0.0;
      for(int j=0; j<nNodes-1; j++) { 
	if(_crossNodeMap.find(f->nodes[j+1]) != _crossNodeMap.end()) {
	  curLen += f->bonds[j]->getLength();
	  if(cossin < 0.0) {
	    if(sqr(curLen)*fabs(cossin) > crit) {
	      double benden = 12.0*kap*shear*fabs(cossin)/curLen;
	      en2return += benden;
	    }
	    else en2return += mu*sqr(shear)*curLen*sqr(cossin)/2.0;
	  }
	  else{
	    en2return += mu*sqr(shear)*curLen*sqr(cossin)/2.0;
	  }
	  curLen = 0.0;
	}
	else curLen += f->bonds[j]->getLength();
      }
    }
    
    return en2return;
  }

  template<int N>
  void SemiflexibleGel<N>::printLongShortStats(double shear, double L, double longshortratio) {
    double shortAffDiff, shortStretchEnergy, shortBendEnergy, shortDistDiff;
    double longAffDiff, longStretchEnergy, longBendEnergy, longDistDiff;
    //Fil based affinity measure:
    // sum((sum((theta-thetaAffine)^2)/nSeg))/nFil
    shortAffDiff = 0.0;
    shortStretchEnergy = 0.0;
    shortBendEnergy = 0.0;
    shortDistDiff = 0.0;
    longAffDiff = 0.0;
    longStretchEnergy = 0.0;
    longBendEnergy = 0.0;
    longDistDiff = 0.0;
    int nshort = 0;
    int nlong = 0;

    //Bill's method: average angle over filament and then calculate nonaffinity
    // sum((sum(theta)/nSeg - thetaAffine)^2)/nFil
    double shortAffDiffBill, longAffDiffBill;
    shortAffDiffBill = 0.0;
    longAffDiffBill = 0.0;

    for(FilamentIterator f=_filaments.begin(); f!=_filaments.end(); f++) {
      double AffDiff = 0.0;
      double thetaActual2 = 0.0;//Bill's method
      double StretchEnergy = 0.0;
      double BendEnergy = 0.0;
      double DistDiff = 0.0;

      int nNodes = (*f)->nodes.size();
      for(int a=0; a<nNodes-1; a++) {
	DefNode* n1 = (*f)->nodes[a];
	DefNode* n2 = (*f)->nodes[a+1];
	const VectorND & p1 = n1->point();
	const VectorND & p2 = n2->point();
	const VectorND & P1 = n1->position();
	const VectorND & P2 = n2->position();
	VectorND d0,d1;
	d0 = P2 - P1;
	d1 = p2 - p1;
	//d0 = d0/norm2(d0);
	//d1 = d1/norm2(d1);
	//double angle = dot(d0,d1);

	double thetaAff = atan2(d0[1],d0[0]+(shear*d0[1]));
	double thetaActual = atan2(d1[1],d1[0]);
	double angle = fabs(thetaActual-thetaAff) < M_PI ? thetaActual-thetaAff : 2.0*M_PI-fabs(thetaActual-thetaAff);
	angle = fabs(angle);
	AffDiff +=  angle * angle;
      }
      AffDiff /= (nNodes-1);

      //Bill's affinity measure
      for(int a=0; a<nNodes-1; a++) {
	DefNode* n1 = (*f)->nodes[a];
	DefNode* n2 = (*f)->nodes[a+1];
	const VectorND & p1 = n1->point();
	const VectorND & p2 = n2->point();
	const VectorND & P1 = n1->position();
	const VectorND & P2 = n2->position();
	VectorND d0,d1;
	d0 = P2 - P1;
	d1 = p2 - p1;

	//double thetaAff = atan2(d0[1],d0[0]+(shear*d0[1]));
	double thetaActual = atan2(d1[1],d1[0]);
	thetaActual2 += thetaActual;
      }
      thetaActual2 /= (nNodes-1);
      DefNode* n1 = (*f)->nodes[0];
      DefNode* n2 = (*f)->nodes[nNodes-1];
      const VectorND & P1 = n1->position();
      const VectorND & P2 = n2->position();
      VectorND d0;
      d0 = P2 - P1;
      double thetaAff2 = atan2(d0[1],d0[0]+(shear*d0[1]));
      double AffDiff2 = fabs(thetaActual2-thetaAff2) < M_PI ? thetaActual2-thetaAff2 : 2.0*M_PI-fabs(thetaActual2-thetaAff2);
      AffDiff2 = fabs(AffDiff2);

      for(int a=0; a<nNodes; a++) {
	DefNode* n1 = (*f)->nodes[a];
	const VectorND & p1 = n1->point();
	const VectorND & P1 = n1->position();
	VectorND Aff;
	Aff = P1[0]+(shear*P1[1]) , P1[1];
	VectorND diff;
	diff = Aff - p1;
	double dist = norm2(diff);
	DistDiff += dist;
      }
      DistDiff /= nNodes;

      for(int a=0; a < (*f)->bonds.size(); a++) {
	double energy = (*f)->bonds[a]->energy();
	StretchEnergy += energy;
      }
      //StretchEnergy /= (*f)->bonds.size();

      for(int a=0; a < (*f)->angles.size(); a++) {
	double energy = (*f)->angles[a]->energy();
	BendEnergy += energy;
      }
      //BendEnergy /= (*f)->angles.size();

      n1 = (*f)->nodes[0];
      n2 = (*f)->nodes[(*f)->nodes.size()-1];
      const VectorND & p1 = n1->point();
      const VectorND & p2 = n2->point();
      VectorND diff;
      diff = p2 - p1;
      double dist = norm2(diff);
      if (dist > 0.5*L*longshortratio){
	//long filament
	longAffDiff += AffDiff;
	longStretchEnergy += StretchEnergy;
	longBendEnergy += BendEnergy;
	longDistDiff += DistDiff;
	nlong++;
	longAffDiffBill += AffDiff2 * AffDiff2;
      }
      else {
	//short filament
	shortAffDiff += AffDiff;
	shortStretchEnergy += StretchEnergy;
	shortBendEnergy += BendEnergy;
	shortDistDiff += DistDiff;
	nshort++;
	shortAffDiffBill += AffDiff2 * AffDiff2;
      }
    }

    shortAffDiff /= nshort;
    //shortStretchEnergy /= nshort;
    //shortBendEnergy /= nshort;
    shortDistDiff /= nshort;
    shortAffDiffBill /= nshort;

    longAffDiff /= nlong;
    //longStretchEnergy /= nlong;
    //longBendEnergy /= nlong;
    longDistDiff /= nlong;
    longAffDiffBill /= nlong;
    double totalEnergy;
    totalEnergy = longStretchEnergy + longBendEnergy + shortStretchEnergy + shortBendEnergy;
    std::cout << std::endl << "Number of long filaments: " << nlong << std::endl
              << "Long: Averaged (per filament) angle difference between actual and affine: " << longAffDiff << std::endl
              << "Long: Total stretching energy: " << longStretchEnergy << "Percentage(over total energy): " << longStretchEnergy/totalEnergy << std::endl
              << "Long: Total bending energy: " << longBendEnergy << "Percentage(over total energy): " << longBendEnergy/totalEnergy <<  std::endl
              << "Long: Averaged (per filament) distance between actual and affine node: " << longDistDiff << std::endl
              << "Long: Averaged (per filament) angle difference between actual and affine (Bill's method)" << longAffDiffBill << std::endl
	      << std::endl << "Number of short filaments: " << nshort << std::endl
              << "Short: Averaged (per filament) angle difference between actual and affine: " << shortAffDiff << std::endl
              << "Short: Total stretching energy: " << shortStretchEnergy << "Percentage(over total energy): " << shortStretchEnergy/totalEnergy << std::endl
              << "Short: Total bending energy: " << shortBendEnergy << "Percentage(over total energy): " << shortBendEnergy/totalEnergy <<  std::endl
              << "Short: Stretching energy percentage: " << shortStretchEnergy/(shortStretchEnergy+shortBendEnergy) << std::endl
              << "Short: Averaged (per filament) distance between actual and affine node: " << shortDistDiff << std::endl
              << "Short: Averaged (per filament) angle difference between actual and affine (Bill's method)" << shortAffDiffBill << std::endl;

  }
};
